// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
use prisma_client_rust::{
	bigdecimal::{self, FromPrimitive},
	chrono,
	datamodel::parse_configuration,
	operator::Operator,
	prisma_models::{InternalDataModelBuilder, PrismaValue},
	queries::{QueryContext, QueryInfo, Result as QueryResult},
	query_core::{
		executor, schema_builder, BuildMode, CoreError, InterpreterError, QueryExecutor,
		QueryGraphBuilderError, QuerySchema, QueryValue, Selection,
	},
	serde_json, transform_equals, BatchResult, Direction, ManyArgs, SerializedWhere,
	SerializedWhereValue, UniqueArgs,
};
pub use prisma_client_rust::{queries::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
static DATAMODEL_STR : & 'static str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:dev.db\"\n}\n\ngenerator client {\n    provider = \"cargo prisma\"\n    output   = \"../src/prisma.rs\"\n}\n\n// generator crdt {\n//     provider = \"cargo prisma-crdt\"\n//     output   = \"../src/_prisma-crdt.rs\"\n// }\n\n/// @local\nmodel OwnedOperation {\n    id        Int   @id @default(autoincrement())\n    timestamp Bytes\n    data      Bytes\n\n    node_id Int\n    node    Node @relation(fields: [node_id], references: [local_id])\n\n    @@map(\"shared_operations\")\n}\n\n/// @local\nmodel SharedOperation {\n    id        Int   @id @default(autoincrement())\n    timestamp Bytes\n    record_id Bytes\n\n    // the type of operation - c, u{field name}, d\n    kind String\n    data Bytes\n\n    node_id Int\n    node    Node @relation(fields: [node_id], references: [local_id])\n\n    @@map(\"relation_operation\")\n}\n\n/// @local\nmodel RelationOperation {\n    id        Int   @id @default(autoincrement())\n    timestamp Bytes\n\n    relation       String\n    relation_item  Bytes\n    relation_group Bytes\n\n    kind String\n    data Bytes\n\n    node_id Int\n    node    Node @relation(fields: [node_id], references: [local_id])\n}\n\n/// @local(id: id)\nmodel Node {\n    local_id Int   @id @default(autoincrement())\n    id       Bytes @unique\n\n    name String\n\n    locations Location[]\n\n    owned_operations    OwnedOperation[]\n    shared_operations   SharedOperation[]\n    relation_operations RelationOperation[]\n\n    @@map(\"nodes\")\n}\n\n// @owned(owner: node, id: id)\nmodel Location {\n    local_id Int   @id @default(autoincrement())\n    id       Bytes @unique\n\n    node_id Int\n    node    Node @relation(fields: [node_id], references: [local_id]) /// @node\n\n    name String\n\n    file_paths FilePath[]\n\n    @@map(\"locations\")\n}\n\n/// @owned(owner: location)\nmodel FilePath {\n    id Int \n\n    location_id Int\n    location    Location @relation(fields: [location_id], references: [local_id])\n\n    parent_id Int?\n    parent    FilePath? @relation(\"directory_file_paths\", fields: [location_id, parent_id], references: [location_id, id])\n\n    file_id Int?\n    File    File? @relation(fields: [file_id], references: [local_id])\n\n    name String\n\n    children FilePath[] @relation(\"directory_file_paths\")\n\n    @@id([location_id, id])\n    @@map(\"file_paths\")\n}\n\n/// A unique record that can represent multiple physical copies of a file.\n/// Existence is implied based on an equivalent file path existing, and could be\n/// created multiple times.\n///\n/// @shared(id: cas_id)\nmodel File {\n    local_id Int   @id @default(autoincrement())\n    cas_id   Bytes @unique\n\n    file_paths FilePath[]\n    TagOnFile  TagOnFile[]\n\n    @@map(\"files\")\n}\n\n/// @shared(id: id)\nmodel Tag {\n    local_id Int   @id @default(autoincrement())\n    id       Bytes @unique\n\n    name String @default(\"\")\n\n    TagOnFile TagOnFile[]\n    @@map(\"tags\")\n}\n\n/// @relation(item: file, group: tag)\nmodel TagOnFile {\n    tag_id Int\n    tag    Tag @relation(fields: [tag_id], references: [local_id])\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [local_id])\n\n    @@id([tag_id, file_id])\n    @@map(\"tags_on_files\")\n}\n" ;
static DATABASE_STR: &'static str = "sqlite";
pub async fn new_client() -> Result<_prisma::PrismaClient, NewClientError> {
	let config = parse_configuration(DATAMODEL_STR)?.subject;
	let source = config
		.datasources
		.first()
		.expect("Pleasy supply a datasource in your schema.prisma file");
	let url = if let Some(url) = source.load_shadow_database_url()? {
		url
	} else {
		source.load_url(|key| std::env::var(key).ok())?
	};
	let url = if url.starts_with("file:") {
		let path = url.split(":").nth(1).unwrap();
		if Path::new("./schema.prisma").exists() {
			url
		} else if Path::new("./prisma/schema.prisma").exists() {
			format!("file:./prisma/{}", path)
		} else {
			url
		}
	} else {
		url
	};
	new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<_prisma::PrismaClient, NewClientError> {
	let config = parse_configuration(DATAMODEL_STR)?.subject;
	let source = config
		.datasources
		.first()
		.expect("Pleasy supply a datasource in your schema.prisma file");
	let (db_name, executor) = executor::load(&source, &[], &url).await?;
	let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
	let query_schema = Arc::new(schema_builder::build(
		internal_model,
		BuildMode::Modern,
		true,
		source.capabilities(),
		vec![],
		source.referential_integrity(),
	));
	executor.primary_connector().get_connection().await?;
	Ok(PrismaClient::_new(executor, query_schema))
}
pub mod owned_operation {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn cursor(cursor: i32) -> Cursor {
			Cursor::Id(cursor)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::IdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::IdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::IdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::IdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::IdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
	}
	pub mod timestamp {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::TimestampEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Timestamp(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::TimestampInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::TimestampNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::TimestampNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTimestamp(value.0)
			}
		}
	}
	pub mod data {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::DataEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Data(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::DataInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::DataNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::DataNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetData(value.0)
			}
		}
	}
	pub mod node_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::NodeIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::NodeId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::NodeIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::NodeIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::NodeIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::NodeIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::NodeIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::NodeIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::NodeIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementNodeId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementNodeId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyNodeId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideNodeId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetNodeId(value.0)
			}
		}
	}
	pub mod node {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIs(value)
		}
		pub fn is_not(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIsNot(value)
		}
		pub struct Fetch {
			args: node::UniqueArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<node::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Node(fetch.args)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch {
				args: node::UniqueArgs::new(),
			}
		}
		pub fn link<T: From<Link>>(value: node::UniqueWhereParam) -> T {
			Link(value).into()
		}
		pub struct Link(node::UniqueWhereParam);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkNode(value.0)
			}
		}
	}
	pub fn _outputs() -> Vec<Selection> {
		["id", "timestamp", "data", "node_id"]
			.into_iter()
			.map(|o| {
				let builder = Selection::builder(o);
				builder.build()
			})
			.collect()
	}
	#[derive(Debug, Clone, Serialize, Deserialize)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "timestamp")]
		pub timestamp: Vec<u8>,
		#[serde(rename = "data")]
		pub data: Vec<u8>,
		#[serde(rename = "node_id")]
		pub node_id: i32,
		#[serde(rename = "node")]
		pub node: Option<Box<super::node::Data>>,
	}
	impl Data {
		pub fn node(&self) -> Result<&super::node::Data, &'static str> {
			self.node
				.as_ref()
				.ok_or("Attempted to access 'node' but did not fetch it using the .with() syntax")
				.map(|v| v.as_ref())
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Node(super::node::UniqueArgs),
	}
	impl Into<Selection> for WithParam {
		fn into(self) -> Selection {
			match self {
				Self::Node(args) => {
					let mut selections = super::node::_outputs();
					selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
					let mut builder = Selection::builder("node");
					builder.nested_selections(selections);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetTimestamp(Vec<u8>),
		SetData(Vec<u8>),
		SetNodeId(i32),
		IncrementNodeId(i32),
		DecrementNodeId(i32),
		MultiplyNodeId(i32),
		DivideNodeId(i32),
		LinkNode(super::node::UniqueWhereParam),
	}
	impl Into<(String, PrismaValue)> for SetParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				SetParam::SetId(value) => ("id".to_string(), PrismaValue::Int(value as i64)),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetTimestamp(value) => {
					("timestamp".to_string(), PrismaValue::Bytes(value))
				}
				SetParam::SetData(value) => ("data".to_string(), PrismaValue::Bytes(value)),
				SetParam::SetNodeId(value) => {
					("node_id".to_string(), PrismaValue::Int(value as i64))
				}
				SetParam::IncrementNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::LinkNode(where_param) => (
					"node".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							vec![Into::<super::node::WhereParam>::into(where_param)].into_iter(),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(Direction),
		Timestamp(Direction),
		Data(Direction),
		NodeId(Direction),
	}
	impl Into<(String, PrismaValue)> for OrderByParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::Id(direction) => {
					("id".to_string(), PrismaValue::String(direction.to_string()))
				}
				Self::Timestamp(direction) => (
					"timestamp".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Data(direction) => (
					"data".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::NodeId(direction) => (
					"node_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum Cursor {
		Id(i32),
	}
	impl Into<(String, PrismaValue)> for Cursor {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::Id(cursor) => ("id".to_string(), PrismaValue::Int(cursor as i64)),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i32),
		IdInVec(Vec<i32>),
		IdNotInVec(Vec<i32>),
		IdLt(i32),
		IdLte(i32),
		IdGt(i32),
		IdGte(i32),
		IdNot(i32),
		TimestampEquals(Vec<u8>),
		TimestampInVec(Vec<Vec<u8>>),
		TimestampNotInVec(Vec<Vec<u8>>),
		TimestampNot(Vec<u8>),
		DataEquals(Vec<u8>),
		DataInVec(Vec<Vec<u8>>),
		DataNotInVec(Vec<Vec<u8>>),
		DataNot(Vec<u8>),
		NodeIdEquals(i32),
		NodeIdInVec(Vec<i32>),
		NodeIdNotInVec(Vec<i32>),
		NodeIdLt(i32),
		NodeIdLte(i32),
		NodeIdGt(i32),
		NodeIdGte(i32),
		NodeIdNot(i32),
		NodeIs(Vec<super::node::WhereParam>),
		NodeIsNot(Vec<super::node::WhereParam>),
	}
	impl Into<SerializedWhere> for WhereParam {
		fn into(self) -> SerializedWhere {
			match self {
				Self::Not(value) => (
					"NOT".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::Or(value) => (
					"OR".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::IdEquals(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdNotInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdLt(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdLte(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGt(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGte(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdNot(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::TimestampEquals(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::TimestampInVec(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::TimestampNotInVec(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::TimestampNot(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::DataEquals(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::DataInVec(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::DataNotInVec(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::DataNot(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::NodeIdEquals(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdInVec(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::NodeIdNotInVec(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::NodeIdLt(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdLte(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdGt(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdGte(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdNot(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIs(value) => (
					"node".to_string(),
					SerializedWhereValue::Object(vec![(
						"is".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::NodeIsNot(value) => (
					"node".to_string(),
					SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<Operator<Self>> for WhereParam {
		fn from(op: Operator<Self>) -> Self {
			match op {
				Operator::Not(value) => Self::Not(value),
				Operator::And(value) => Self::And(value),
				Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
	pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type FindUnique<'a> =
		prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		Cursor,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> =
		prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
	pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn create(
			self,
			timestamp: timestamp::Set,
			data: data::Set,
			node: node::Link,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(timestamp.into());
			_params.push(data.into());
			_params.push(node.into());
			Create::new(
				self.client._new_query_context(),
				QueryInfo::new("OwnedOperation", _outputs()),
				_params,
			)
		}
		pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				QueryInfo::new("OwnedOperation", _outputs()),
				param.into(),
			)
		}
		pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				QueryInfo::new("OwnedOperation", _outputs()),
				params,
			)
		}
		pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				QueryInfo::new("OwnedOperation", _outputs()),
				params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: (timestamp::Set, data::Set, node::Link, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			let (timestamp, data, node, mut _params) = _create;
			_params.push(timestamp.into());
			_params.push(data.into());
			_params.push(node.into());
			Upsert::new(
				self.client._new_query_context(),
				QueryInfo::new("OwnedOperation", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
	}
}
pub mod shared_operation {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn cursor(cursor: i32) -> Cursor {
			Cursor::Id(cursor)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::IdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::IdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::IdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::IdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::IdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
	}
	pub mod timestamp {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::TimestampEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Timestamp(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::TimestampInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::TimestampNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::TimestampNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTimestamp(value.0)
			}
		}
	}
	pub mod record_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::RecordIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::RecordId(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::RecordIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::RecordIdNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::RecordIdNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetRecordId(value.0)
			}
		}
	}
	pub mod kind {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::KindEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Kind(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::KindInVec(value)
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::KindNotInVec(value)
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::KindLt(value)
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::KindLte(value)
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::KindGt(value)
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::KindGte(value)
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::KindContains(value)
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::KindStartsWith(value)
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::KindEndsWith(value)
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::KindNot(value)
		}
		pub struct Set(String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetKind(value.0)
			}
		}
	}
	pub mod data {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::DataEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Data(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::DataInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::DataNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::DataNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetData(value.0)
			}
		}
	}
	pub mod node_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::NodeIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::NodeId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::NodeIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::NodeIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::NodeIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::NodeIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::NodeIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::NodeIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::NodeIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementNodeId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementNodeId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyNodeId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideNodeId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetNodeId(value.0)
			}
		}
	}
	pub mod node {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIs(value)
		}
		pub fn is_not(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIsNot(value)
		}
		pub struct Fetch {
			args: node::UniqueArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<node::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Node(fetch.args)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch {
				args: node::UniqueArgs::new(),
			}
		}
		pub fn link<T: From<Link>>(value: node::UniqueWhereParam) -> T {
			Link(value).into()
		}
		pub struct Link(node::UniqueWhereParam);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkNode(value.0)
			}
		}
	}
	pub fn _outputs() -> Vec<Selection> {
		["id", "timestamp", "record_id", "kind", "data", "node_id"]
			.into_iter()
			.map(|o| {
				let builder = Selection::builder(o);
				builder.build()
			})
			.collect()
	}
	#[derive(Debug, Clone, Serialize, Deserialize)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "timestamp")]
		pub timestamp: Vec<u8>,
		#[serde(rename = "record_id")]
		pub record_id: Vec<u8>,
		#[serde(rename = "kind")]
		pub kind: String,
		#[serde(rename = "data")]
		pub data: Vec<u8>,
		#[serde(rename = "node_id")]
		pub node_id: i32,
		#[serde(rename = "node")]
		pub node: Option<Box<super::node::Data>>,
	}
	impl Data {
		pub fn node(&self) -> Result<&super::node::Data, &'static str> {
			self.node
				.as_ref()
				.ok_or("Attempted to access 'node' but did not fetch it using the .with() syntax")
				.map(|v| v.as_ref())
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Node(super::node::UniqueArgs),
	}
	impl Into<Selection> for WithParam {
		fn into(self) -> Selection {
			match self {
				Self::Node(args) => {
					let mut selections = super::node::_outputs();
					selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
					let mut builder = Selection::builder("node");
					builder.nested_selections(selections);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetTimestamp(Vec<u8>),
		SetRecordId(Vec<u8>),
		SetKind(String),
		SetData(Vec<u8>),
		SetNodeId(i32),
		IncrementNodeId(i32),
		DecrementNodeId(i32),
		MultiplyNodeId(i32),
		DivideNodeId(i32),
		LinkNode(super::node::UniqueWhereParam),
	}
	impl Into<(String, PrismaValue)> for SetParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				SetParam::SetId(value) => ("id".to_string(), PrismaValue::Int(value as i64)),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetTimestamp(value) => {
					("timestamp".to_string(), PrismaValue::Bytes(value))
				}
				SetParam::SetRecordId(value) => {
					("record_id".to_string(), PrismaValue::Bytes(value))
				}
				SetParam::SetKind(value) => ("kind".to_string(), PrismaValue::String(value)),
				SetParam::SetData(value) => ("data".to_string(), PrismaValue::Bytes(value)),
				SetParam::SetNodeId(value) => {
					("node_id".to_string(), PrismaValue::Int(value as i64))
				}
				SetParam::IncrementNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::LinkNode(where_param) => (
					"node".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							vec![Into::<super::node::WhereParam>::into(where_param)].into_iter(),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(Direction),
		Timestamp(Direction),
		RecordId(Direction),
		Kind(Direction),
		Data(Direction),
		NodeId(Direction),
	}
	impl Into<(String, PrismaValue)> for OrderByParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::Id(direction) => {
					("id".to_string(), PrismaValue::String(direction.to_string()))
				}
				Self::Timestamp(direction) => (
					"timestamp".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::RecordId(direction) => (
					"record_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Kind(direction) => (
					"kind".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Data(direction) => (
					"data".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::NodeId(direction) => (
					"node_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum Cursor {
		Id(i32),
	}
	impl Into<(String, PrismaValue)> for Cursor {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::Id(cursor) => ("id".to_string(), PrismaValue::Int(cursor as i64)),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i32),
		IdInVec(Vec<i32>),
		IdNotInVec(Vec<i32>),
		IdLt(i32),
		IdLte(i32),
		IdGt(i32),
		IdGte(i32),
		IdNot(i32),
		TimestampEquals(Vec<u8>),
		TimestampInVec(Vec<Vec<u8>>),
		TimestampNotInVec(Vec<Vec<u8>>),
		TimestampNot(Vec<u8>),
		RecordIdEquals(Vec<u8>),
		RecordIdInVec(Vec<Vec<u8>>),
		RecordIdNotInVec(Vec<Vec<u8>>),
		RecordIdNot(Vec<u8>),
		KindEquals(String),
		KindInVec(Vec<String>),
		KindNotInVec(Vec<String>),
		KindLt(String),
		KindLte(String),
		KindGt(String),
		KindGte(String),
		KindContains(String),
		KindStartsWith(String),
		KindEndsWith(String),
		KindNot(String),
		DataEquals(Vec<u8>),
		DataInVec(Vec<Vec<u8>>),
		DataNotInVec(Vec<Vec<u8>>),
		DataNot(Vec<u8>),
		NodeIdEquals(i32),
		NodeIdInVec(Vec<i32>),
		NodeIdNotInVec(Vec<i32>),
		NodeIdLt(i32),
		NodeIdLte(i32),
		NodeIdGt(i32),
		NodeIdGte(i32),
		NodeIdNot(i32),
		NodeIs(Vec<super::node::WhereParam>),
		NodeIsNot(Vec<super::node::WhereParam>),
	}
	impl Into<SerializedWhere> for WhereParam {
		fn into(self) -> SerializedWhere {
			match self {
				Self::Not(value) => (
					"NOT".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::Or(value) => (
					"OR".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::IdEquals(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdNotInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdLt(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdLte(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGt(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGte(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdNot(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::TimestampEquals(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::TimestampInVec(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::TimestampNotInVec(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::TimestampNot(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::RecordIdEquals(value) => (
					"record_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::RecordIdInVec(value) => (
					"record_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::RecordIdNotInVec(value) => (
					"record_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::RecordIdNot(value) => (
					"record_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::KindEquals(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindInVec(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::KindNotInVec(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::KindLt(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindLte(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindGt(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindGte(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindContains(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindStartsWith(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindEndsWith(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindNot(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::DataEquals(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::DataInVec(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::DataNotInVec(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::DataNot(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::NodeIdEquals(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdInVec(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::NodeIdNotInVec(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::NodeIdLt(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdLte(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdGt(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdGte(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdNot(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIs(value) => (
					"node".to_string(),
					SerializedWhereValue::Object(vec![(
						"is".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::NodeIsNot(value) => (
					"node".to_string(),
					SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<Operator<Self>> for WhereParam {
		fn from(op: Operator<Self>) -> Self {
			match op {
				Operator::Not(value) => Self::Not(value),
				Operator::And(value) => Self::And(value),
				Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
	pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type FindUnique<'a> =
		prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		Cursor,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> =
		prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
	pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn create(
			self,
			timestamp: timestamp::Set,
			record_id: record_id::Set,
			kind: kind::Set,
			data: data::Set,
			node: node::Link,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(timestamp.into());
			_params.push(record_id.into());
			_params.push(kind.into());
			_params.push(data.into());
			_params.push(node.into());
			Create::new(
				self.client._new_query_context(),
				QueryInfo::new("SharedOperation", _outputs()),
				_params,
			)
		}
		pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				QueryInfo::new("SharedOperation", _outputs()),
				param.into(),
			)
		}
		pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				QueryInfo::new("SharedOperation", _outputs()),
				params,
			)
		}
		pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				QueryInfo::new("SharedOperation", _outputs()),
				params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: (
				timestamp::Set,
				record_id::Set,
				kind::Set,
				data::Set,
				node::Link,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			let (timestamp, record_id, kind, data, node, mut _params) = _create;
			_params.push(timestamp.into());
			_params.push(record_id.into());
			_params.push(kind.into());
			_params.push(data.into());
			_params.push(node.into());
			Upsert::new(
				self.client._new_query_context(),
				QueryInfo::new("SharedOperation", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
	}
}
pub mod relation_operation {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn cursor(cursor: i32) -> Cursor {
			Cursor::Id(cursor)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::IdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::IdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::IdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::IdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::IdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
	}
	pub mod timestamp {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::TimestampEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Timestamp(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::TimestampInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::TimestampNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::TimestampNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTimestamp(value.0)
			}
		}
	}
	pub mod relation {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::RelationEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Relation(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::RelationInVec(value)
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::RelationNotInVec(value)
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::RelationLt(value)
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::RelationLte(value)
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::RelationGt(value)
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::RelationGte(value)
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::RelationContains(value)
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::RelationStartsWith(value)
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::RelationEndsWith(value)
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::RelationNot(value)
		}
		pub struct Set(String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetRelation(value.0)
			}
		}
	}
	pub mod relation_item {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::RelationItemEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::RelationItem(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::RelationItemInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::RelationItemNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::RelationItemNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetRelationItem(value.0)
			}
		}
	}
	pub mod relation_group {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::RelationGroupEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::RelationGroup(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::RelationGroupInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::RelationGroupNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::RelationGroupNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetRelationGroup(value.0)
			}
		}
	}
	pub mod kind {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::KindEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Kind(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::KindInVec(value)
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::KindNotInVec(value)
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::KindLt(value)
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::KindLte(value)
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::KindGt(value)
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::KindGte(value)
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::KindContains(value)
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::KindStartsWith(value)
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::KindEndsWith(value)
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::KindNot(value)
		}
		pub struct Set(String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetKind(value.0)
			}
		}
	}
	pub mod data {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::DataEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Data(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::DataInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::DataNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::DataNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetData(value.0)
			}
		}
	}
	pub mod node_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::NodeIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::NodeId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::NodeIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::NodeIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::NodeIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::NodeIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::NodeIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::NodeIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::NodeIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementNodeId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementNodeId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyNodeId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideNodeId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetNodeId(value.0)
			}
		}
	}
	pub mod node {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIs(value)
		}
		pub fn is_not(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIsNot(value)
		}
		pub struct Fetch {
			args: node::UniqueArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<node::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Node(fetch.args)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch {
				args: node::UniqueArgs::new(),
			}
		}
		pub fn link<T: From<Link>>(value: node::UniqueWhereParam) -> T {
			Link(value).into()
		}
		pub struct Link(node::UniqueWhereParam);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkNode(value.0)
			}
		}
	}
	pub fn _outputs() -> Vec<Selection> {
		[
			"id",
			"timestamp",
			"relation",
			"relation_item",
			"relation_group",
			"kind",
			"data",
			"node_id",
		]
		.into_iter()
		.map(|o| {
			let builder = Selection::builder(o);
			builder.build()
		})
		.collect()
	}
	#[derive(Debug, Clone, Serialize, Deserialize)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "timestamp")]
		pub timestamp: Vec<u8>,
		#[serde(rename = "relation")]
		pub relation: String,
		#[serde(rename = "relation_item")]
		pub relation_item: Vec<u8>,
		#[serde(rename = "relation_group")]
		pub relation_group: Vec<u8>,
		#[serde(rename = "kind")]
		pub kind: String,
		#[serde(rename = "data")]
		pub data: Vec<u8>,
		#[serde(rename = "node_id")]
		pub node_id: i32,
		#[serde(rename = "node")]
		pub node: Option<Box<super::node::Data>>,
	}
	impl Data {
		pub fn node(&self) -> Result<&super::node::Data, &'static str> {
			self.node
				.as_ref()
				.ok_or("Attempted to access 'node' but did not fetch it using the .with() syntax")
				.map(|v| v.as_ref())
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Node(super::node::UniqueArgs),
	}
	impl Into<Selection> for WithParam {
		fn into(self) -> Selection {
			match self {
				Self::Node(args) => {
					let mut selections = super::node::_outputs();
					selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
					let mut builder = Selection::builder("node");
					builder.nested_selections(selections);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetTimestamp(Vec<u8>),
		SetRelation(String),
		SetRelationItem(Vec<u8>),
		SetRelationGroup(Vec<u8>),
		SetKind(String),
		SetData(Vec<u8>),
		SetNodeId(i32),
		IncrementNodeId(i32),
		DecrementNodeId(i32),
		MultiplyNodeId(i32),
		DivideNodeId(i32),
		LinkNode(super::node::UniqueWhereParam),
	}
	impl Into<(String, PrismaValue)> for SetParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				SetParam::SetId(value) => ("id".to_string(), PrismaValue::Int(value as i64)),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetTimestamp(value) => {
					("timestamp".to_string(), PrismaValue::Bytes(value))
				}
				SetParam::SetRelation(value) => {
					("relation".to_string(), PrismaValue::String(value))
				}
				SetParam::SetRelationItem(value) => {
					("relation_item".to_string(), PrismaValue::Bytes(value))
				}
				SetParam::SetRelationGroup(value) => {
					("relation_group".to_string(), PrismaValue::Bytes(value))
				}
				SetParam::SetKind(value) => ("kind".to_string(), PrismaValue::String(value)),
				SetParam::SetData(value) => ("data".to_string(), PrismaValue::Bytes(value)),
				SetParam::SetNodeId(value) => {
					("node_id".to_string(), PrismaValue::Int(value as i64))
				}
				SetParam::IncrementNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::LinkNode(where_param) => (
					"node".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							vec![Into::<super::node::WhereParam>::into(where_param)].into_iter(),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(Direction),
		Timestamp(Direction),
		Relation(Direction),
		RelationItem(Direction),
		RelationGroup(Direction),
		Kind(Direction),
		Data(Direction),
		NodeId(Direction),
	}
	impl Into<(String, PrismaValue)> for OrderByParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::Id(direction) => {
					("id".to_string(), PrismaValue::String(direction.to_string()))
				}
				Self::Timestamp(direction) => (
					"timestamp".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Relation(direction) => (
					"relation".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::RelationItem(direction) => (
					"relation_item".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::RelationGroup(direction) => (
					"relation_group".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Kind(direction) => (
					"kind".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Data(direction) => (
					"data".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::NodeId(direction) => (
					"node_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum Cursor {
		Id(i32),
	}
	impl Into<(String, PrismaValue)> for Cursor {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::Id(cursor) => ("id".to_string(), PrismaValue::Int(cursor as i64)),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i32),
		IdInVec(Vec<i32>),
		IdNotInVec(Vec<i32>),
		IdLt(i32),
		IdLte(i32),
		IdGt(i32),
		IdGte(i32),
		IdNot(i32),
		TimestampEquals(Vec<u8>),
		TimestampInVec(Vec<Vec<u8>>),
		TimestampNotInVec(Vec<Vec<u8>>),
		TimestampNot(Vec<u8>),
		RelationEquals(String),
		RelationInVec(Vec<String>),
		RelationNotInVec(Vec<String>),
		RelationLt(String),
		RelationLte(String),
		RelationGt(String),
		RelationGte(String),
		RelationContains(String),
		RelationStartsWith(String),
		RelationEndsWith(String),
		RelationNot(String),
		RelationItemEquals(Vec<u8>),
		RelationItemInVec(Vec<Vec<u8>>),
		RelationItemNotInVec(Vec<Vec<u8>>),
		RelationItemNot(Vec<u8>),
		RelationGroupEquals(Vec<u8>),
		RelationGroupInVec(Vec<Vec<u8>>),
		RelationGroupNotInVec(Vec<Vec<u8>>),
		RelationGroupNot(Vec<u8>),
		KindEquals(String),
		KindInVec(Vec<String>),
		KindNotInVec(Vec<String>),
		KindLt(String),
		KindLte(String),
		KindGt(String),
		KindGte(String),
		KindContains(String),
		KindStartsWith(String),
		KindEndsWith(String),
		KindNot(String),
		DataEquals(Vec<u8>),
		DataInVec(Vec<Vec<u8>>),
		DataNotInVec(Vec<Vec<u8>>),
		DataNot(Vec<u8>),
		NodeIdEquals(i32),
		NodeIdInVec(Vec<i32>),
		NodeIdNotInVec(Vec<i32>),
		NodeIdLt(i32),
		NodeIdLte(i32),
		NodeIdGt(i32),
		NodeIdGte(i32),
		NodeIdNot(i32),
		NodeIs(Vec<super::node::WhereParam>),
		NodeIsNot(Vec<super::node::WhereParam>),
	}
	impl Into<SerializedWhere> for WhereParam {
		fn into(self) -> SerializedWhere {
			match self {
				Self::Not(value) => (
					"NOT".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::Or(value) => (
					"OR".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::IdEquals(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdNotInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdLt(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdLte(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGt(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGte(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdNot(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::TimestampEquals(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::TimestampInVec(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::TimestampNotInVec(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::TimestampNot(value) => (
					"timestamp".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::RelationEquals(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::RelationInVec(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::RelationNotInVec(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::RelationLt(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::RelationLte(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::RelationGt(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::RelationGte(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::RelationContains(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::RelationStartsWith(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::RelationEndsWith(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::RelationNot(value) => (
					"relation".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::RelationItemEquals(value) => (
					"relation_item".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::RelationItemInVec(value) => (
					"relation_item".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::RelationItemNotInVec(value) => (
					"relation_item".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::RelationItemNot(value) => (
					"relation_item".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::RelationGroupEquals(value) => (
					"relation_group".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::RelationGroupInVec(value) => (
					"relation_group".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::RelationGroupNotInVec(value) => (
					"relation_group".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::RelationGroupNot(value) => (
					"relation_group".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::KindEquals(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindInVec(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::KindNotInVec(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::KindLt(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindLte(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindGt(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindGte(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindContains(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindStartsWith(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindEndsWith(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::KindNot(value) => (
					"kind".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::DataEquals(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::DataInVec(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::DataNotInVec(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::DataNot(value) => (
					"data".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::NodeIdEquals(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdInVec(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::NodeIdNotInVec(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::NodeIdLt(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdLte(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdGt(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdGte(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdNot(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIs(value) => (
					"node".to_string(),
					SerializedWhereValue::Object(vec![(
						"is".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::NodeIsNot(value) => (
					"node".to_string(),
					SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<Operator<Self>> for WhereParam {
		fn from(op: Operator<Self>) -> Self {
			match op {
				Operator::Not(value) => Self::Not(value),
				Operator::And(value) => Self::And(value),
				Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
	pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type FindUnique<'a> =
		prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		Cursor,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> =
		prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
	pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn create(
			self,
			timestamp: timestamp::Set,
			relation: relation::Set,
			relation_item: relation_item::Set,
			relation_group: relation_group::Set,
			kind: kind::Set,
			data: data::Set,
			node: node::Link,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(timestamp.into());
			_params.push(relation.into());
			_params.push(relation_item.into());
			_params.push(relation_group.into());
			_params.push(kind.into());
			_params.push(data.into());
			_params.push(node.into());
			Create::new(
				self.client._new_query_context(),
				QueryInfo::new("RelationOperation", _outputs()),
				_params,
			)
		}
		pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				QueryInfo::new("RelationOperation", _outputs()),
				param.into(),
			)
		}
		pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				QueryInfo::new("RelationOperation", _outputs()),
				params,
			)
		}
		pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				QueryInfo::new("RelationOperation", _outputs()),
				params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: (
				timestamp::Set,
				relation::Set,
				relation_item::Set,
				relation_group::Set,
				kind::Set,
				data::Set,
				node::Link,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			let (timestamp, relation, relation_item, relation_group, kind, data, node, mut _params) =
				_create;
			_params.push(timestamp.into());
			_params.push(relation.into());
			_params.push(relation_item.into());
			_params.push(relation_group.into());
			_params.push(kind.into());
			_params.push(data.into());
			_params.push(node.into());
			Upsert::new(
				self.client._new_query_context(),
				QueryInfo::new("RelationOperation", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
	}
}
pub mod node {
	use super::_prisma::*;
	use super::*;
	pub mod local_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::LocalIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::LocalId(direction)
		}
		pub fn cursor(cursor: i32) -> Cursor {
			Cursor::LocalId(cursor)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::LocalIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::LocalIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::LocalIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::LocalIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::LocalIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::LocalIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::LocalIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementLocalId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementLocalId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyLocalId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideLocalId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetLocalId(value.0)
			}
		}
	}
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn cursor(cursor: Vec<u8>) -> Cursor {
			Cursor::Id(cursor)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::IdInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::IdNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::IdNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
	}
	pub mod name {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::NameEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Name(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NameInVec(value)
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NameNotInVec(value)
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::NameLt(value)
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::NameLte(value)
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::NameGt(value)
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::NameGte(value)
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::NameContains(value)
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::NameStartsWith(value)
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::NameEndsWith(value)
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::NameNot(value)
		}
		pub struct Set(String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetName(value.0)
			}
		}
	}
	pub mod locations {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationsSome(value)
		}
		pub fn every(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationsEvery(value)
		}
		pub fn none(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationsNone(value)
		}
		pub struct Fetch {
			args: location::ManyArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<location::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
			pub fn order_by(mut self, param: location::OrderByParam) -> Self {
				self.args = self.args.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.args = self.args.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.args = self.args.take(value);
				self
			}
			pub fn cursor(mut self, value: impl Into<location::Cursor>) -> Self {
				self.args = self.args.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Locations(fetch.args)
			}
		}
		pub fn fetch(params: Vec<location::WhereParam>) -> Fetch {
			Fetch {
				args: location::ManyArgs::new(params),
			}
		}
		pub fn link<T: From<Link>>(params: Vec<location::UniqueWhereParam>) -> T {
			Link(params).into()
		}
		pub fn unlink(params: Vec<location::UniqueWhereParam>) -> SetParam {
			SetParam::UnlinkLocations(params)
		}
		pub struct Link(Vec<location::UniqueWhereParam>);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkLocations(value.0)
			}
		}
	}
	pub mod owned_operations {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<owned_operation::WhereParam>) -> WhereParam {
			WhereParam::OwnedOperationsSome(value)
		}
		pub fn every(value: Vec<owned_operation::WhereParam>) -> WhereParam {
			WhereParam::OwnedOperationsEvery(value)
		}
		pub fn none(value: Vec<owned_operation::WhereParam>) -> WhereParam {
			WhereParam::OwnedOperationsNone(value)
		}
		pub struct Fetch {
			args: owned_operation::ManyArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<owned_operation::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
			pub fn order_by(mut self, param: owned_operation::OrderByParam) -> Self {
				self.args = self.args.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.args = self.args.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.args = self.args.take(value);
				self
			}
			pub fn cursor(mut self, value: impl Into<owned_operation::Cursor>) -> Self {
				self.args = self.args.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::OwnedOperations(fetch.args)
			}
		}
		pub fn fetch(params: Vec<owned_operation::WhereParam>) -> Fetch {
			Fetch {
				args: owned_operation::ManyArgs::new(params),
			}
		}
		pub fn link<T: From<Link>>(params: Vec<owned_operation::UniqueWhereParam>) -> T {
			Link(params).into()
		}
		pub fn unlink(params: Vec<owned_operation::UniqueWhereParam>) -> SetParam {
			SetParam::UnlinkOwnedOperations(params)
		}
		pub struct Link(Vec<owned_operation::UniqueWhereParam>);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkOwnedOperations(value.0)
			}
		}
	}
	pub mod shared_operations {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<shared_operation::WhereParam>) -> WhereParam {
			WhereParam::SharedOperationsSome(value)
		}
		pub fn every(value: Vec<shared_operation::WhereParam>) -> WhereParam {
			WhereParam::SharedOperationsEvery(value)
		}
		pub fn none(value: Vec<shared_operation::WhereParam>) -> WhereParam {
			WhereParam::SharedOperationsNone(value)
		}
		pub struct Fetch {
			args: shared_operation::ManyArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<shared_operation::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
			pub fn order_by(mut self, param: shared_operation::OrderByParam) -> Self {
				self.args = self.args.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.args = self.args.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.args = self.args.take(value);
				self
			}
			pub fn cursor(mut self, value: impl Into<shared_operation::Cursor>) -> Self {
				self.args = self.args.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::SharedOperations(fetch.args)
			}
		}
		pub fn fetch(params: Vec<shared_operation::WhereParam>) -> Fetch {
			Fetch {
				args: shared_operation::ManyArgs::new(params),
			}
		}
		pub fn link<T: From<Link>>(params: Vec<shared_operation::UniqueWhereParam>) -> T {
			Link(params).into()
		}
		pub fn unlink(params: Vec<shared_operation::UniqueWhereParam>) -> SetParam {
			SetParam::UnlinkSharedOperations(params)
		}
		pub struct Link(Vec<shared_operation::UniqueWhereParam>);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkSharedOperations(value.0)
			}
		}
	}
	pub mod relation_operations {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<relation_operation::WhereParam>) -> WhereParam {
			WhereParam::RelationOperationsSome(value)
		}
		pub fn every(value: Vec<relation_operation::WhereParam>) -> WhereParam {
			WhereParam::RelationOperationsEvery(value)
		}
		pub fn none(value: Vec<relation_operation::WhereParam>) -> WhereParam {
			WhereParam::RelationOperationsNone(value)
		}
		pub struct Fetch {
			args: relation_operation::ManyArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<relation_operation::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
			pub fn order_by(mut self, param: relation_operation::OrderByParam) -> Self {
				self.args = self.args.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.args = self.args.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.args = self.args.take(value);
				self
			}
			pub fn cursor(mut self, value: impl Into<relation_operation::Cursor>) -> Self {
				self.args = self.args.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::RelationOperations(fetch.args)
			}
		}
		pub fn fetch(params: Vec<relation_operation::WhereParam>) -> Fetch {
			Fetch {
				args: relation_operation::ManyArgs::new(params),
			}
		}
		pub fn link<T: From<Link>>(params: Vec<relation_operation::UniqueWhereParam>) -> T {
			Link(params).into()
		}
		pub fn unlink(params: Vec<relation_operation::UniqueWhereParam>) -> SetParam {
			SetParam::UnlinkRelationOperations(params)
		}
		pub struct Link(Vec<relation_operation::UniqueWhereParam>);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkRelationOperations(value.0)
			}
		}
	}
	pub fn _outputs() -> Vec<Selection> {
		["local_id", "id", "name"]
			.into_iter()
			.map(|o| {
				let builder = Selection::builder(o);
				builder.build()
			})
			.collect()
	}
	#[derive(Debug, Clone, Serialize, Deserialize)]
	pub struct Data {
		#[serde(rename = "local_id")]
		pub local_id: i32,
		#[serde(rename = "id")]
		pub id: Vec<u8>,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "locations")]
		pub locations: Option<Vec<super::location::Data>>,
		#[serde(rename = "owned_operations")]
		pub owned_operations: Option<Vec<super::owned_operation::Data>>,
		#[serde(rename = "shared_operations")]
		pub shared_operations: Option<Vec<super::shared_operation::Data>>,
		#[serde(rename = "relation_operations")]
		pub relation_operations: Option<Vec<super::relation_operation::Data>>,
	}
	impl Data {
		pub fn locations(&self) -> Result<&Vec<super::location::Data>, &'static str> {
			self.locations.as_ref().ok_or(
				"Attempted to access 'locations' but did not fetch it using the .with() syntax",
			)
		}
		pub fn owned_operations(&self) -> Result<&Vec<super::owned_operation::Data>, &'static str> {
			self . owned_operations . as_ref () . ok_or ("Attempted to access 'owned_operations' but did not fetch it using the .with() syntax")
		}
		pub fn shared_operations(
			&self,
		) -> Result<&Vec<super::shared_operation::Data>, &'static str> {
			self . shared_operations . as_ref () . ok_or ("Attempted to access 'shared_operations' but did not fetch it using the .with() syntax")
		}
		pub fn relation_operations(
			&self,
		) -> Result<&Vec<super::relation_operation::Data>, &'static str> {
			self . relation_operations . as_ref () . ok_or ("Attempted to access 'relation_operations' but did not fetch it using the .with() syntax")
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Locations(super::location::ManyArgs),
		OwnedOperations(super::owned_operation::ManyArgs),
		SharedOperations(super::shared_operation::ManyArgs),
		RelationOperations(super::relation_operation::ManyArgs),
	}
	impl Into<Selection> for WithParam {
		fn into(self) -> Selection {
			match self {
				Self::Locations(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(super::location::_outputs());
					let mut builder = Selection::builder("locations");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
				Self::OwnedOperations(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(super::owned_operation::_outputs());
					let mut builder = Selection::builder("owned_operations");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
				Self::SharedOperations(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(super::shared_operation::_outputs());
					let mut builder = Selection::builder("shared_operations");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
				Self::RelationOperations(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(super::relation_operation::_outputs());
					let mut builder = Selection::builder("relation_operations");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetLocalId(i32),
		IncrementLocalId(i32),
		DecrementLocalId(i32),
		MultiplyLocalId(i32),
		DivideLocalId(i32),
		SetId(Vec<u8>),
		SetName(String),
		LinkLocations(Vec<super::location::UniqueWhereParam>),
		UnlinkLocations(Vec<super::location::UniqueWhereParam>),
		LinkOwnedOperations(Vec<super::owned_operation::UniqueWhereParam>),
		UnlinkOwnedOperations(Vec<super::owned_operation::UniqueWhereParam>),
		LinkSharedOperations(Vec<super::shared_operation::UniqueWhereParam>),
		UnlinkSharedOperations(Vec<super::shared_operation::UniqueWhereParam>),
		LinkRelationOperations(Vec<super::relation_operation::UniqueWhereParam>),
		UnlinkRelationOperations(Vec<super::relation_operation::UniqueWhereParam>),
	}
	impl Into<(String, PrismaValue)> for SetParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				SetParam::SetLocalId(value) => {
					("local_id".to_string(), PrismaValue::Int(value as i64))
				}
				SetParam::IncrementLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetId(value) => ("id".to_string(), PrismaValue::Bytes(value)),
				SetParam::SetName(value) => ("name".to_string(), PrismaValue::String(value)),
				SetParam::LinkLocations(where_params) => (
					"locations".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							where_params
								.into_iter()
								.map(Into::<super::location::WhereParam>::into),
						)),
					)]),
				),
				SetParam::UnlinkLocations(where_params) => (
					"locations".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Object(
							transform_equals(
								where_params
									.into_iter()
									.map(Into::<super::location::WhereParam>::into),
							)
							.into_iter()
							.collect(),
						),
					)]),
				),
				SetParam::LinkOwnedOperations(where_params) => (
					"owned_operations".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							where_params
								.into_iter()
								.map(Into::<super::owned_operation::WhereParam>::into),
						)),
					)]),
				),
				SetParam::UnlinkOwnedOperations(where_params) => (
					"owned_operations".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Object(
							transform_equals(
								where_params
									.into_iter()
									.map(Into::<super::owned_operation::WhereParam>::into),
							)
							.into_iter()
							.collect(),
						),
					)]),
				),
				SetParam::LinkSharedOperations(where_params) => (
					"shared_operations".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							where_params
								.into_iter()
								.map(Into::<super::shared_operation::WhereParam>::into),
						)),
					)]),
				),
				SetParam::UnlinkSharedOperations(where_params) => (
					"shared_operations".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Object(
							transform_equals(
								where_params
									.into_iter()
									.map(Into::<super::shared_operation::WhereParam>::into),
							)
							.into_iter()
							.collect(),
						),
					)]),
				),
				SetParam::LinkRelationOperations(where_params) => (
					"relation_operations".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							where_params
								.into_iter()
								.map(Into::<super::relation_operation::WhereParam>::into),
						)),
					)]),
				),
				SetParam::UnlinkRelationOperations(where_params) => (
					"relation_operations".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Object(
							transform_equals(
								where_params
									.into_iter()
									.map(Into::<super::relation_operation::WhereParam>::into),
							)
							.into_iter()
							.collect(),
						),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		LocalId(Direction),
		Id(Direction),
		Name(Direction),
	}
	impl Into<(String, PrismaValue)> for OrderByParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::LocalId(direction) => (
					"local_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Id(direction) => {
					("id".to_string(), PrismaValue::String(direction.to_string()))
				}
				Self::Name(direction) => (
					"name".to_string(),
					PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum Cursor {
		LocalId(i32),
		Id(Vec<u8>),
	}
	impl Into<(String, PrismaValue)> for Cursor {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::LocalId(cursor) => ("local_id".to_string(), PrismaValue::Int(cursor as i64)),
				Self::Id(cursor) => ("id".to_string(), PrismaValue::Bytes(cursor)),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LocalIdEquals(i32),
		LocalIdInVec(Vec<i32>),
		LocalIdNotInVec(Vec<i32>),
		LocalIdLt(i32),
		LocalIdLte(i32),
		LocalIdGt(i32),
		LocalIdGte(i32),
		LocalIdNot(i32),
		IdEquals(Vec<u8>),
		IdInVec(Vec<Vec<u8>>),
		IdNotInVec(Vec<Vec<u8>>),
		IdNot(Vec<u8>),
		NameEquals(String),
		NameInVec(Vec<String>),
		NameNotInVec(Vec<String>),
		NameLt(String),
		NameLte(String),
		NameGt(String),
		NameGte(String),
		NameContains(String),
		NameStartsWith(String),
		NameEndsWith(String),
		NameNot(String),
		LocationsSome(Vec<super::location::WhereParam>),
		LocationsEvery(Vec<super::location::WhereParam>),
		LocationsNone(Vec<super::location::WhereParam>),
		OwnedOperationsSome(Vec<super::owned_operation::WhereParam>),
		OwnedOperationsEvery(Vec<super::owned_operation::WhereParam>),
		OwnedOperationsNone(Vec<super::owned_operation::WhereParam>),
		SharedOperationsSome(Vec<super::shared_operation::WhereParam>),
		SharedOperationsEvery(Vec<super::shared_operation::WhereParam>),
		SharedOperationsNone(Vec<super::shared_operation::WhereParam>),
		RelationOperationsSome(Vec<super::relation_operation::WhereParam>),
		RelationOperationsEvery(Vec<super::relation_operation::WhereParam>),
		RelationOperationsNone(Vec<super::relation_operation::WhereParam>),
	}
	impl Into<SerializedWhere> for WhereParam {
		fn into(self) -> SerializedWhere {
			match self {
				Self::Not(value) => (
					"NOT".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::Or(value) => (
					"OR".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::LocalIdEquals(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdInVec(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::LocalIdNotInVec(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::LocalIdLt(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdLte(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdGt(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdGte(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdNot(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdEquals(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::IdInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::IdNotInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::IdNot(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::NameEquals(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameInVec(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::NameNotInVec(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::NameLt(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameLte(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameGt(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameGte(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameContains(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameStartsWith(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameEndsWith(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameNot(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::LocationsSome(value) => (
					"locations".to_string(),
					SerializedWhereValue::Object(vec![(
						"some".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::LocationsEvery(value) => (
					"locations".to_string(),
					SerializedWhereValue::Object(vec![(
						"every".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::LocationsNone(value) => (
					"locations".to_string(),
					SerializedWhereValue::Object(vec![(
						"none".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::OwnedOperationsSome(value) => (
					"owned_operations".to_string(),
					SerializedWhereValue::Object(vec![(
						"some".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::OwnedOperationsEvery(value) => (
					"owned_operations".to_string(),
					SerializedWhereValue::Object(vec![(
						"every".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::OwnedOperationsNone(value) => (
					"owned_operations".to_string(),
					SerializedWhereValue::Object(vec![(
						"none".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::SharedOperationsSome(value) => (
					"shared_operations".to_string(),
					SerializedWhereValue::Object(vec![(
						"some".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::SharedOperationsEvery(value) => (
					"shared_operations".to_string(),
					SerializedWhereValue::Object(vec![(
						"every".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::SharedOperationsNone(value) => (
					"shared_operations".to_string(),
					SerializedWhereValue::Object(vec![(
						"none".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::RelationOperationsSome(value) => (
					"relation_operations".to_string(),
					SerializedWhereValue::Object(vec![(
						"some".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::RelationOperationsEvery(value) => (
					"relation_operations".to_string(),
					SerializedWhereValue::Object(vec![(
						"every".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::RelationOperationsNone(value) => (
					"relation_operations".to_string(),
					SerializedWhereValue::Object(vec![(
						"none".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(Vec<u8>),
		LocalIdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
				UniqueWhereParam::LocalIdEquals(value) => Self::LocalIdEquals(value),
			}
		}
	}
	impl From<Operator<Self>> for WhereParam {
		fn from(op: Operator<Self>) -> Self {
			match op {
				Operator::Not(value) => Self::Not(value),
				Operator::And(value) => Self::And(value),
				Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
	pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type FindUnique<'a> =
		prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		Cursor,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> =
		prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
	pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn create(
			self,
			id: id::Set,
			name: name::Set,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(id.into());
			_params.push(name.into());
			Create::new(
				self.client._new_query_context(),
				QueryInfo::new("Node", _outputs()),
				_params,
			)
		}
		pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				QueryInfo::new("Node", _outputs()),
				param.into(),
			)
		}
		pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				QueryInfo::new("Node", _outputs()),
				params,
			)
		}
		pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				QueryInfo::new("Node", _outputs()),
				params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: (id::Set, name::Set, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			let (id, name, mut _params) = _create;
			_params.push(id.into());
			_params.push(name.into());
			Upsert::new(
				self.client._new_query_context(),
				QueryInfo::new("Node", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
	}
}
pub mod location {
	use super::_prisma::*;
	use super::*;
	pub mod local_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::LocalIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::LocalId(direction)
		}
		pub fn cursor(cursor: i32) -> Cursor {
			Cursor::LocalId(cursor)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::LocalIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::LocalIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::LocalIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::LocalIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::LocalIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::LocalIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::LocalIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementLocalId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementLocalId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyLocalId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideLocalId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetLocalId(value.0)
			}
		}
	}
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn cursor(cursor: Vec<u8>) -> Cursor {
			Cursor::Id(cursor)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::IdInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::IdNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::IdNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
	}
	pub mod node_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::NodeIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::NodeId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::NodeIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::NodeIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::NodeIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::NodeIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::NodeIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::NodeIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::NodeIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementNodeId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementNodeId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyNodeId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideNodeId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetNodeId(value.0)
			}
		}
	}
	pub mod node {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIs(value)
		}
		pub fn is_not(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIsNot(value)
		}
		pub struct Fetch {
			args: node::UniqueArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<node::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Node(fetch.args)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch {
				args: node::UniqueArgs::new(),
			}
		}
		pub fn link<T: From<Link>>(value: node::UniqueWhereParam) -> T {
			Link(value).into()
		}
		pub struct Link(node::UniqueWhereParam);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkNode(value.0)
			}
		}
	}
	pub mod name {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::NameEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Name(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NameInVec(value)
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NameNotInVec(value)
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::NameLt(value)
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::NameLte(value)
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::NameGt(value)
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::NameGte(value)
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::NameContains(value)
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::NameStartsWith(value)
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::NameEndsWith(value)
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::NameNot(value)
		}
		pub struct Set(String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetName(value.0)
			}
		}
	}
	pub mod file_paths {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsSome(value)
		}
		pub fn every(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsEvery(value)
		}
		pub fn none(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsNone(value)
		}
		pub struct Fetch {
			args: file_path::ManyArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<file_path::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
			pub fn order_by(mut self, param: file_path::OrderByParam) -> Self {
				self.args = self.args.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.args = self.args.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.args = self.args.take(value);
				self
			}
			pub fn cursor(mut self, value: impl Into<file_path::Cursor>) -> Self {
				self.args = self.args.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::FilePaths(fetch.args)
			}
		}
		pub fn fetch(params: Vec<file_path::WhereParam>) -> Fetch {
			Fetch {
				args: file_path::ManyArgs::new(params),
			}
		}
		pub fn link<T: From<Link>>(params: Vec<file_path::UniqueWhereParam>) -> T {
			Link(params).into()
		}
		pub fn unlink(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::UnlinkFilePaths(params)
		}
		pub struct Link(Vec<file_path::UniqueWhereParam>);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkFilePaths(value.0)
			}
		}
	}
	pub fn _outputs() -> Vec<Selection> {
		["local_id", "id", "node_id", "name"]
			.into_iter()
			.map(|o| {
				let builder = Selection::builder(o);
				builder.build()
			})
			.collect()
	}
	#[derive(Debug, Clone, Serialize, Deserialize)]
	pub struct Data {
		#[serde(rename = "local_id")]
		pub local_id: i32,
		#[serde(rename = "id")]
		pub id: Vec<u8>,
		#[serde(rename = "node_id")]
		pub node_id: i32,
		#[serde(rename = "node")]
		pub node: Option<Box<super::node::Data>>,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "file_paths")]
		pub file_paths: Option<Vec<super::file_path::Data>>,
	}
	impl Data {
		pub fn node(&self) -> Result<&super::node::Data, &'static str> {
			self.node
				.as_ref()
				.ok_or("Attempted to access 'node' but did not fetch it using the .with() syntax")
				.map(|v| v.as_ref())
		}
		pub fn file_paths(&self) -> Result<&Vec<super::file_path::Data>, &'static str> {
			self.file_paths.as_ref().ok_or(
				"Attempted to access 'file_paths' but did not fetch it using the .with() syntax",
			)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Node(super::node::UniqueArgs),
		FilePaths(super::file_path::ManyArgs),
	}
	impl Into<Selection> for WithParam {
		fn into(self) -> Selection {
			match self {
				Self::Node(args) => {
					let mut selections = super::node::_outputs();
					selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
					let mut builder = Selection::builder("node");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::FilePaths(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(super::file_path::_outputs());
					let mut builder = Selection::builder("file_paths");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetLocalId(i32),
		IncrementLocalId(i32),
		DecrementLocalId(i32),
		MultiplyLocalId(i32),
		DivideLocalId(i32),
		SetId(Vec<u8>),
		SetNodeId(i32),
		IncrementNodeId(i32),
		DecrementNodeId(i32),
		MultiplyNodeId(i32),
		DivideNodeId(i32),
		LinkNode(super::node::UniqueWhereParam),
		SetName(String),
		LinkFilePaths(Vec<super::file_path::UniqueWhereParam>),
		UnlinkFilePaths(Vec<super::file_path::UniqueWhereParam>),
	}
	impl Into<(String, PrismaValue)> for SetParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				SetParam::SetLocalId(value) => {
					("local_id".to_string(), PrismaValue::Int(value as i64))
				}
				SetParam::IncrementLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetId(value) => ("id".to_string(), PrismaValue::Bytes(value)),
				SetParam::SetNodeId(value) => {
					("node_id".to_string(), PrismaValue::Int(value as i64))
				}
				SetParam::IncrementNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideNodeId(value) => (
					"node_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::LinkNode(where_param) => (
					"node".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							vec![Into::<super::node::WhereParam>::into(where_param)].into_iter(),
						)),
					)]),
				),
				SetParam::SetName(value) => ("name".to_string(), PrismaValue::String(value)),
				SetParam::LinkFilePaths(where_params) => (
					"file_paths".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into),
						)),
					)]),
				),
				SetParam::UnlinkFilePaths(where_params) => (
					"file_paths".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Object(
							transform_equals(
								where_params
									.into_iter()
									.map(Into::<super::file_path::WhereParam>::into),
							)
							.into_iter()
							.collect(),
						),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		LocalId(Direction),
		Id(Direction),
		NodeId(Direction),
		Name(Direction),
	}
	impl Into<(String, PrismaValue)> for OrderByParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::LocalId(direction) => (
					"local_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Id(direction) => {
					("id".to_string(), PrismaValue::String(direction.to_string()))
				}
				Self::NodeId(direction) => (
					"node_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Name(direction) => (
					"name".to_string(),
					PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum Cursor {
		LocalId(i32),
		Id(Vec<u8>),
	}
	impl Into<(String, PrismaValue)> for Cursor {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::LocalId(cursor) => ("local_id".to_string(), PrismaValue::Int(cursor as i64)),
				Self::Id(cursor) => ("id".to_string(), PrismaValue::Bytes(cursor)),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LocalIdEquals(i32),
		LocalIdInVec(Vec<i32>),
		LocalIdNotInVec(Vec<i32>),
		LocalIdLt(i32),
		LocalIdLte(i32),
		LocalIdGt(i32),
		LocalIdGte(i32),
		LocalIdNot(i32),
		IdEquals(Vec<u8>),
		IdInVec(Vec<Vec<u8>>),
		IdNotInVec(Vec<Vec<u8>>),
		IdNot(Vec<u8>),
		NodeIdEquals(i32),
		NodeIdInVec(Vec<i32>),
		NodeIdNotInVec(Vec<i32>),
		NodeIdLt(i32),
		NodeIdLte(i32),
		NodeIdGt(i32),
		NodeIdGte(i32),
		NodeIdNot(i32),
		NodeIs(Vec<super::node::WhereParam>),
		NodeIsNot(Vec<super::node::WhereParam>),
		NameEquals(String),
		NameInVec(Vec<String>),
		NameNotInVec(Vec<String>),
		NameLt(String),
		NameLte(String),
		NameGt(String),
		NameGte(String),
		NameContains(String),
		NameStartsWith(String),
		NameEndsWith(String),
		NameNot(String),
		FilePathsSome(Vec<super::file_path::WhereParam>),
		FilePathsEvery(Vec<super::file_path::WhereParam>),
		FilePathsNone(Vec<super::file_path::WhereParam>),
	}
	impl Into<SerializedWhere> for WhereParam {
		fn into(self) -> SerializedWhere {
			match self {
				Self::Not(value) => (
					"NOT".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::Or(value) => (
					"OR".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::LocalIdEquals(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdInVec(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::LocalIdNotInVec(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::LocalIdLt(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdLte(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdGt(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdGte(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdNot(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdEquals(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::IdInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::IdNotInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::IdNot(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::NodeIdEquals(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdInVec(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::NodeIdNotInVec(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::NodeIdLt(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdLte(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdGt(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdGte(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIdNot(value) => (
					"node_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::NodeIs(value) => (
					"node".to_string(),
					SerializedWhereValue::Object(vec![(
						"is".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::NodeIsNot(value) => (
					"node".to_string(),
					SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::NameEquals(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameInVec(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::NameNotInVec(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::NameLt(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameLte(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameGt(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameGte(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameContains(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameStartsWith(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameEndsWith(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameNot(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::FilePathsSome(value) => (
					"file_paths".to_string(),
					SerializedWhereValue::Object(vec![(
						"some".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::FilePathsEvery(value) => (
					"file_paths".to_string(),
					SerializedWhereValue::Object(vec![(
						"every".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::FilePathsNone(value) => (
					"file_paths".to_string(),
					SerializedWhereValue::Object(vec![(
						"none".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(Vec<u8>),
		LocalIdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
				UniqueWhereParam::LocalIdEquals(value) => Self::LocalIdEquals(value),
			}
		}
	}
	impl From<Operator<Self>> for WhereParam {
		fn from(op: Operator<Self>) -> Self {
			match op {
				Operator::Not(value) => Self::Not(value),
				Operator::And(value) => Self::And(value),
				Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
	pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type FindUnique<'a> =
		prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		Cursor,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> =
		prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
	pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn create(
			self,
			id: id::Set,
			node: node::Link,
			name: name::Set,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(id.into());
			_params.push(node.into());
			_params.push(name.into());
			Create::new(
				self.client._new_query_context(),
				QueryInfo::new("Location", _outputs()),
				_params,
			)
		}
		pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				QueryInfo::new("Location", _outputs()),
				param.into(),
			)
		}
		pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				QueryInfo::new("Location", _outputs()),
				params,
			)
		}
		pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				QueryInfo::new("Location", _outputs()),
				params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: (id::Set, node::Link, name::Set, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			let (id, node, name, mut _params) = _create;
			_params.push(id.into());
			_params.push(node.into());
			_params.push(name.into());
			Upsert::new(
				self.client._new_query_context(),
				QueryInfo::new("Location", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
	}
}
pub mod file_path {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::IdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::IdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::IdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::IdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::IdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::IdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
	}
	pub mod location_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::LocationIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::LocationId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::LocationIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::LocationIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::LocationIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::LocationIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::LocationIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::LocationIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::LocationIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementLocationId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementLocationId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyLocationId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideLocationId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetLocationId(value.0)
			}
		}
	}
	pub mod location {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationIs(value)
		}
		pub fn is_not(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationIsNot(value)
		}
		pub struct Fetch {
			args: location::UniqueArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<location::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Location(fetch.args)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch {
				args: location::UniqueArgs::new(),
			}
		}
		pub fn link<T: From<Link>>(value: location::UniqueWhereParam) -> T {
			Link(value).into()
		}
		pub struct Link(location::UniqueWhereParam);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkLocation(value.0)
			}
		}
	}
	pub mod parent_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::ParentIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::ParentId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::ParentIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::ParentIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::ParentIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::ParentIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::ParentIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::ParentIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::ParentIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementParentId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementParentId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyParentId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideParentId(value)
		}
		pub struct Set(Option<i32>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetParentId(value.0)
			}
		}
	}
	pub mod parent {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::ParentIs(value)
		}
		pub fn is_not(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::ParentIsNot(value)
		}
		pub struct Fetch {
			args: file_path::UniqueArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<file_path::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Parent(fetch.args)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch {
				args: file_path::UniqueArgs::new(),
			}
		}
		pub fn link<T: From<Link>>(value: file_path::UniqueWhereParam) -> T {
			Link(value).into()
		}
		pub fn unlink() -> SetParam {
			SetParam::UnlinkParent
		}
		pub struct Link(file_path::UniqueWhereParam);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkParent(value.0)
			}
		}
	}
	pub mod file_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::FileIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::FileId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::FileIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::FileIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::FileIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::FileIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::FileIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::FileIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::FileIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementFileId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementFileId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyFileId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideFileId(value)
		}
		pub struct Set(Option<i32>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetFileId(value.0)
			}
		}
	}
	pub mod file {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<file::WhereParam>) -> WhereParam {
			WhereParam::FileIs(value)
		}
		pub fn is_not(value: Vec<file::WhereParam>) -> WhereParam {
			WhereParam::FileIsNot(value)
		}
		pub struct Fetch {
			args: file::UniqueArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<file::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::File(fetch.args)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch {
				args: file::UniqueArgs::new(),
			}
		}
		pub fn link<T: From<Link>>(value: file::UniqueWhereParam) -> T {
			Link(value).into()
		}
		pub fn unlink() -> SetParam {
			SetParam::UnlinkFile
		}
		pub struct Link(file::UniqueWhereParam);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkFile(value.0)
			}
		}
	}
	pub mod name {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::NameEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Name(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NameInVec(value)
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NameNotInVec(value)
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::NameLt(value)
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::NameLte(value)
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::NameGt(value)
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::NameGte(value)
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::NameContains(value)
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::NameStartsWith(value)
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::NameEndsWith(value)
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::NameNot(value)
		}
		pub struct Set(String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetName(value.0)
			}
		}
	}
	pub mod children {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::ChildrenSome(value)
		}
		pub fn every(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::ChildrenEvery(value)
		}
		pub fn none(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::ChildrenNone(value)
		}
		pub struct Fetch {
			args: file_path::ManyArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<file_path::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
			pub fn order_by(mut self, param: file_path::OrderByParam) -> Self {
				self.args = self.args.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.args = self.args.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.args = self.args.take(value);
				self
			}
			pub fn cursor(mut self, value: impl Into<file_path::Cursor>) -> Self {
				self.args = self.args.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Children(fetch.args)
			}
		}
		pub fn fetch(params: Vec<file_path::WhereParam>) -> Fetch {
			Fetch {
				args: file_path::ManyArgs::new(params),
			}
		}
		pub fn link<T: From<Link>>(params: Vec<file_path::UniqueWhereParam>) -> T {
			Link(params).into()
		}
		pub fn unlink(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::UnlinkChildren(params)
		}
		pub struct Link(Vec<file_path::UniqueWhereParam>);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkChildren(value.0)
			}
		}
	}
	pub fn location_id_id<T: From<UniqueWhereParam>>(location_id: i32, id: i32) -> T {
		UniqueWhereParam::LocationIdIdEquals(location_id, id).into()
	}
	pub fn _outputs() -> Vec<Selection> {
		["id", "location_id", "parent_id", "file_id", "name"]
			.into_iter()
			.map(|o| {
				let builder = Selection::builder(o);
				builder.build()
			})
			.collect()
	}
	#[derive(Debug, Clone, Serialize, Deserialize)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "location_id")]
		pub location_id: i32,
		#[serde(rename = "location")]
		pub location: Option<Box<super::location::Data>>,
		#[serde(rename = "parent_id")]
		pub parent_id: Option<i32>,
		#[serde(
			rename = "parent",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		pub parent: Option<Option<Box<super::file_path::Data>>>,
		#[serde(rename = "file_id")]
		pub file_id: Option<i32>,
		#[serde(
			rename = "File",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		pub file: Option<Option<Box<super::file::Data>>>,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "children")]
		pub children: Option<Vec<super::file_path::Data>>,
	}
	impl Data {
		pub fn location(&self) -> Result<&super::location::Data, &'static str> {
			self.location
				.as_ref()
				.ok_or(
					"Attempted to access 'location' but did not fetch it using the .with() syntax",
				)
				.map(|v| v.as_ref())
		}
		pub fn parent(&self) -> Result<Option<&super::file_path::Data>, &'static str> {
			self.parent
				.as_ref()
				.ok_or("Attempted to access 'parent' but did not fetch it using the .with() syntax")
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
		pub fn file(&self) -> Result<Option<&super::file::Data>, &'static str> {
			self.file
				.as_ref()
				.ok_or("Attempted to access 'file' but did not fetch it using the .with() syntax")
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
		pub fn children(&self) -> Result<&Vec<super::file_path::Data>, &'static str> {
			self.children.as_ref().ok_or(
				"Attempted to access 'children' but did not fetch it using the .with() syntax",
			)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Location(super::location::UniqueArgs),
		Parent(super::file_path::UniqueArgs),
		File(super::file::UniqueArgs),
		Children(super::file_path::ManyArgs),
	}
	impl Into<Selection> for WithParam {
		fn into(self) -> Selection {
			match self {
				Self::Location(args) => {
					let mut selections = super::location::_outputs();
					selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
					let mut builder = Selection::builder("location");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::Parent(args) => {
					let mut selections = super::file_path::_outputs();
					selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
					let mut builder = Selection::builder("parent");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::File(args) => {
					let mut selections = super::file::_outputs();
					selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
					let mut builder = Selection::builder("File");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::Children(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(super::file_path::_outputs());
					let mut builder = Selection::builder("children");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetLocationId(i32),
		IncrementLocationId(i32),
		DecrementLocationId(i32),
		MultiplyLocationId(i32),
		DivideLocationId(i32),
		LinkLocation(super::location::UniqueWhereParam),
		SetParentId(Option<i32>),
		IncrementParentId(i32),
		DecrementParentId(i32),
		MultiplyParentId(i32),
		DivideParentId(i32),
		LinkParent(super::file_path::UniqueWhereParam),
		UnlinkParent,
		SetFileId(Option<i32>),
		IncrementFileId(i32),
		DecrementFileId(i32),
		MultiplyFileId(i32),
		DivideFileId(i32),
		LinkFile(super::file::UniqueWhereParam),
		UnlinkFile,
		SetName(String),
		LinkChildren(Vec<super::file_path::UniqueWhereParam>),
		UnlinkChildren(Vec<super::file_path::UniqueWhereParam>),
	}
	impl Into<(String, PrismaValue)> for SetParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				SetParam::SetId(value) => ("id".to_string(), PrismaValue::Int(value as i64)),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetLocationId(value) => {
					("location_id".to_string(), PrismaValue::Int(value as i64))
				}
				SetParam::IncrementLocationId(value) => (
					"location_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementLocationId(value) => (
					"location_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyLocationId(value) => (
					"location_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideLocationId(value) => (
					"location_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::LinkLocation(where_param) => (
					"location".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							vec![Into::<super::location::WhereParam>::into(where_param)]
								.into_iter(),
						)),
					)]),
				),
				SetParam::SetParentId(value) => (
					"parent_id".to_string(),
					value
						.map(|value| PrismaValue::Int(value as i64))
						.unwrap_or(PrismaValue::Null),
				),
				SetParam::IncrementParentId(value) => (
					"parent_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementParentId(value) => (
					"parent_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyParentId(value) => (
					"parent_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideParentId(value) => (
					"parent_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::LinkParent(where_param) => (
					"parent".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							vec![Into::<super::file_path::WhereParam>::into(where_param)]
								.into_iter(),
						)),
					)]),
				),
				SetParam::UnlinkParent => (
					"parent".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Boolean(true),
					)]),
				),
				SetParam::SetFileId(value) => (
					"file_id".to_string(),
					value
						.map(|value| PrismaValue::Int(value as i64))
						.unwrap_or(PrismaValue::Null),
				),
				SetParam::IncrementFileId(value) => (
					"file_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementFileId(value) => (
					"file_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyFileId(value) => (
					"file_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideFileId(value) => (
					"file_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::LinkFile(where_param) => (
					"File".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							vec![Into::<super::file::WhereParam>::into(where_param)].into_iter(),
						)),
					)]),
				),
				SetParam::UnlinkFile => (
					"File".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Boolean(true),
					)]),
				),
				SetParam::SetName(value) => ("name".to_string(), PrismaValue::String(value)),
				SetParam::LinkChildren(where_params) => (
					"children".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into),
						)),
					)]),
				),
				SetParam::UnlinkChildren(where_params) => (
					"children".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Object(
							transform_equals(
								where_params
									.into_iter()
									.map(Into::<super::file_path::WhereParam>::into),
							)
							.into_iter()
							.collect(),
						),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(Direction),
		LocationId(Direction),
		ParentId(Direction),
		FileId(Direction),
		Name(Direction),
	}
	impl Into<(String, PrismaValue)> for OrderByParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::Id(direction) => {
					("id".to_string(), PrismaValue::String(direction.to_string()))
				}
				Self::LocationId(direction) => (
					"location_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::ParentId(direction) => (
					"parent_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::FileId(direction) => (
					"file_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Name(direction) => (
					"name".to_string(),
					PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum Cursor {}
	impl Into<(String, PrismaValue)> for Cursor {
		fn into(self) -> (String, PrismaValue) {
			match self {}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LocationIdIdEquals(i32, i32),
		IdEquals(i32),
		IdInVec(Vec<i32>),
		IdNotInVec(Vec<i32>),
		IdLt(i32),
		IdLte(i32),
		IdGt(i32),
		IdGte(i32),
		IdNot(i32),
		LocationIdEquals(i32),
		LocationIdInVec(Vec<i32>),
		LocationIdNotInVec(Vec<i32>),
		LocationIdLt(i32),
		LocationIdLte(i32),
		LocationIdGt(i32),
		LocationIdGte(i32),
		LocationIdNot(i32),
		LocationIs(Vec<super::location::WhereParam>),
		LocationIsNot(Vec<super::location::WhereParam>),
		ParentIdEquals(Option<i32>),
		ParentIdInVec(Vec<i32>),
		ParentIdNotInVec(Vec<i32>),
		ParentIdLt(i32),
		ParentIdLte(i32),
		ParentIdGt(i32),
		ParentIdGte(i32),
		ParentIdNot(i32),
		ParentIs(Vec<super::file_path::WhereParam>),
		ParentIsNot(Vec<super::file_path::WhereParam>),
		FileIdEquals(Option<i32>),
		FileIdInVec(Vec<i32>),
		FileIdNotInVec(Vec<i32>),
		FileIdLt(i32),
		FileIdLte(i32),
		FileIdGt(i32),
		FileIdGte(i32),
		FileIdNot(i32),
		FileIs(Vec<super::file::WhereParam>),
		FileIsNot(Vec<super::file::WhereParam>),
		NameEquals(String),
		NameInVec(Vec<String>),
		NameNotInVec(Vec<String>),
		NameLt(String),
		NameLte(String),
		NameGt(String),
		NameGte(String),
		NameContains(String),
		NameStartsWith(String),
		NameEndsWith(String),
		NameNot(String),
		ChildrenSome(Vec<super::file_path::WhereParam>),
		ChildrenEvery(Vec<super::file_path::WhereParam>),
		ChildrenNone(Vec<super::file_path::WhereParam>),
	}
	impl Into<SerializedWhere> for WhereParam {
		fn into(self) -> SerializedWhere {
			match self {
				Self::Not(value) => (
					"NOT".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::Or(value) => (
					"OR".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::LocationIdIdEquals(location_id, id) => (
					"location_id_id".to_string(),
					SerializedWhereValue::Object(vec![
						(
							"location_id".to_string(),
							PrismaValue::Int(location_id as i64),
						),
						("id".to_string(), PrismaValue::Int(id as i64)),
					]),
				),
				Self::IdEquals(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdNotInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdLt(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdLte(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGt(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGte(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdNot(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocationIdEquals(value) => (
					"location_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocationIdInVec(value) => (
					"location_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::LocationIdNotInVec(value) => (
					"location_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::LocationIdLt(value) => (
					"location_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocationIdLte(value) => (
					"location_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocationIdGt(value) => (
					"location_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocationIdGte(value) => (
					"location_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocationIdNot(value) => (
					"location_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocationIs(value) => (
					"location".to_string(),
					SerializedWhereValue::Object(vec![(
						"is".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::LocationIsNot(value) => (
					"location".to_string(),
					SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::ParentIdEquals(value) => (
					"parent_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| PrismaValue::Int(value as i64))
							.unwrap_or(PrismaValue::Null),
					)]),
				),
				Self::ParentIdInVec(value) => (
					"parent_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::ParentIdNotInVec(value) => (
					"parent_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::ParentIdLt(value) => (
					"parent_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::ParentIdLte(value) => (
					"parent_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::ParentIdGt(value) => (
					"parent_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::ParentIdGte(value) => (
					"parent_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::ParentIdNot(value) => (
					"parent_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::ParentIs(value) => (
					"parent".to_string(),
					SerializedWhereValue::Object(vec![(
						"is".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::ParentIsNot(value) => (
					"parent".to_string(),
					SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::FileIdEquals(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| PrismaValue::Int(value as i64))
							.unwrap_or(PrismaValue::Null),
					)]),
				),
				Self::FileIdInVec(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::FileIdNotInVec(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::FileIdLt(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIdLte(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIdGt(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIdGte(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIdNot(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIs(value) => (
					"File".to_string(),
					SerializedWhereValue::Object(vec![(
						"is".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::FileIsNot(value) => (
					"File".to_string(),
					SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::NameEquals(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameInVec(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::NameNotInVec(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::NameLt(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameLte(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameGt(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameGte(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameContains(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameStartsWith(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameEndsWith(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameNot(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::ChildrenSome(value) => (
					"children".to_string(),
					SerializedWhereValue::Object(vec![(
						"some".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::ChildrenEvery(value) => (
					"children".to_string(),
					SerializedWhereValue::Object(vec![(
						"every".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::ChildrenNone(value) => (
					"children".to_string(),
					SerializedWhereValue::Object(vec![(
						"none".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		LocationIdIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::LocationIdIdEquals(location_id, id) => {
					Self::LocationIdIdEquals(location_id, id)
				}
			}
		}
	}
	impl From<Operator<Self>> for WhereParam {
		fn from(op: Operator<Self>) -> Self {
			match op {
				Operator::Not(value) => Self::Not(value),
				Operator::And(value) => Self::And(value),
				Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
	pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type FindUnique<'a> =
		prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		Cursor,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> =
		prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
	pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn create(
			self,
			id: id::Set,
			location: location::Link,
			name: name::Set,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(id.into());
			_params.push(location.into());
			_params.push(name.into());
			Create::new(
				self.client._new_query_context(),
				QueryInfo::new("FilePath", _outputs()),
				_params,
			)
		}
		pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				QueryInfo::new("FilePath", _outputs()),
				param.into(),
			)
		}
		pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				QueryInfo::new("FilePath", _outputs()),
				params,
			)
		}
		pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				QueryInfo::new("FilePath", _outputs()),
				params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: (id::Set, location::Link, name::Set, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			let (id, location, name, mut _params) = _create;
			_params.push(id.into());
			_params.push(location.into());
			_params.push(name.into());
			Upsert::new(
				self.client._new_query_context(),
				QueryInfo::new("FilePath", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
	}
}
pub mod file {
	use super::_prisma::*;
	use super::*;
	pub mod local_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::LocalIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::LocalId(direction)
		}
		pub fn cursor(cursor: i32) -> Cursor {
			Cursor::LocalId(cursor)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::LocalIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::LocalIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::LocalIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::LocalIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::LocalIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::LocalIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::LocalIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementLocalId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementLocalId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyLocalId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideLocalId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetLocalId(value.0)
			}
		}
	}
	pub mod cas_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::CasIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::CasId(direction)
		}
		pub fn cursor(cursor: Vec<u8>) -> Cursor {
			Cursor::CasId(cursor)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::CasIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::CasIdNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::CasIdNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetCasId(value.0)
			}
		}
	}
	pub mod file_paths {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsSome(value)
		}
		pub fn every(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsEvery(value)
		}
		pub fn none(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsNone(value)
		}
		pub struct Fetch {
			args: file_path::ManyArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<file_path::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
			pub fn order_by(mut self, param: file_path::OrderByParam) -> Self {
				self.args = self.args.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.args = self.args.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.args = self.args.take(value);
				self
			}
			pub fn cursor(mut self, value: impl Into<file_path::Cursor>) -> Self {
				self.args = self.args.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::FilePaths(fetch.args)
			}
		}
		pub fn fetch(params: Vec<file_path::WhereParam>) -> Fetch {
			Fetch {
				args: file_path::ManyArgs::new(params),
			}
		}
		pub fn link<T: From<Link>>(params: Vec<file_path::UniqueWhereParam>) -> T {
			Link(params).into()
		}
		pub fn unlink(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::UnlinkFilePaths(params)
		}
		pub struct Link(Vec<file_path::UniqueWhereParam>);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkFilePaths(value.0)
			}
		}
	}
	pub mod tag_on_file {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
			WhereParam::TagOnFileSome(value)
		}
		pub fn every(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
			WhereParam::TagOnFileEvery(value)
		}
		pub fn none(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
			WhereParam::TagOnFileNone(value)
		}
		pub struct Fetch {
			args: tag_on_file::ManyArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<tag_on_file::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
			pub fn order_by(mut self, param: tag_on_file::OrderByParam) -> Self {
				self.args = self.args.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.args = self.args.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.args = self.args.take(value);
				self
			}
			pub fn cursor(mut self, value: impl Into<tag_on_file::Cursor>) -> Self {
				self.args = self.args.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::TagOnFile(fetch.args)
			}
		}
		pub fn fetch(params: Vec<tag_on_file::WhereParam>) -> Fetch {
			Fetch {
				args: tag_on_file::ManyArgs::new(params),
			}
		}
		pub fn link<T: From<Link>>(params: Vec<tag_on_file::UniqueWhereParam>) -> T {
			Link(params).into()
		}
		pub fn unlink(params: Vec<tag_on_file::UniqueWhereParam>) -> SetParam {
			SetParam::UnlinkTagOnFile(params)
		}
		pub struct Link(Vec<tag_on_file::UniqueWhereParam>);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkTagOnFile(value.0)
			}
		}
	}
	pub fn _outputs() -> Vec<Selection> {
		["local_id", "cas_id"]
			.into_iter()
			.map(|o| {
				let builder = Selection::builder(o);
				builder.build()
			})
			.collect()
	}
	#[derive(Debug, Clone, Serialize, Deserialize)]
	pub struct Data {
		#[serde(rename = "local_id")]
		pub local_id: i32,
		#[serde(rename = "cas_id")]
		pub cas_id: Vec<u8>,
		#[serde(rename = "file_paths")]
		pub file_paths: Option<Vec<super::file_path::Data>>,
		#[serde(rename = "TagOnFile")]
		pub tag_on_file: Option<Vec<super::tag_on_file::Data>>,
	}
	impl Data {
		pub fn file_paths(&self) -> Result<&Vec<super::file_path::Data>, &'static str> {
			self.file_paths.as_ref().ok_or(
				"Attempted to access 'file_paths' but did not fetch it using the .with() syntax",
			)
		}
		pub fn tag_on_file(&self) -> Result<&Vec<super::tag_on_file::Data>, &'static str> {
			self.tag_on_file.as_ref().ok_or(
				"Attempted to access 'tag_on_file' but did not fetch it using the .with() syntax",
			)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		FilePaths(super::file_path::ManyArgs),
		TagOnFile(super::tag_on_file::ManyArgs),
	}
	impl Into<Selection> for WithParam {
		fn into(self) -> Selection {
			match self {
				Self::FilePaths(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(super::file_path::_outputs());
					let mut builder = Selection::builder("file_paths");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
				Self::TagOnFile(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(super::tag_on_file::_outputs());
					let mut builder = Selection::builder("TagOnFile");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetLocalId(i32),
		IncrementLocalId(i32),
		DecrementLocalId(i32),
		MultiplyLocalId(i32),
		DivideLocalId(i32),
		SetCasId(Vec<u8>),
		LinkFilePaths(Vec<super::file_path::UniqueWhereParam>),
		UnlinkFilePaths(Vec<super::file_path::UniqueWhereParam>),
		LinkTagOnFile(Vec<super::tag_on_file::UniqueWhereParam>),
		UnlinkTagOnFile(Vec<super::tag_on_file::UniqueWhereParam>),
	}
	impl Into<(String, PrismaValue)> for SetParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				SetParam::SetLocalId(value) => {
					("local_id".to_string(), PrismaValue::Int(value as i64))
				}
				SetParam::IncrementLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetCasId(value) => ("cas_id".to_string(), PrismaValue::Bytes(value)),
				SetParam::LinkFilePaths(where_params) => (
					"file_paths".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into),
						)),
					)]),
				),
				SetParam::UnlinkFilePaths(where_params) => (
					"file_paths".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Object(
							transform_equals(
								where_params
									.into_iter()
									.map(Into::<super::file_path::WhereParam>::into),
							)
							.into_iter()
							.collect(),
						),
					)]),
				),
				SetParam::LinkTagOnFile(where_params) => (
					"TagOnFile".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_file::WhereParam>::into),
						)),
					)]),
				),
				SetParam::UnlinkTagOnFile(where_params) => (
					"TagOnFile".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Object(
							transform_equals(
								where_params
									.into_iter()
									.map(Into::<super::tag_on_file::WhereParam>::into),
							)
							.into_iter()
							.collect(),
						),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		LocalId(Direction),
		CasId(Direction),
	}
	impl Into<(String, PrismaValue)> for OrderByParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::LocalId(direction) => (
					"local_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::CasId(direction) => (
					"cas_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum Cursor {
		LocalId(i32),
		CasId(Vec<u8>),
	}
	impl Into<(String, PrismaValue)> for Cursor {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::LocalId(cursor) => ("local_id".to_string(), PrismaValue::Int(cursor as i64)),
				Self::CasId(cursor) => ("cas_id".to_string(), PrismaValue::Bytes(cursor)),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LocalIdEquals(i32),
		LocalIdInVec(Vec<i32>),
		LocalIdNotInVec(Vec<i32>),
		LocalIdLt(i32),
		LocalIdLte(i32),
		LocalIdGt(i32),
		LocalIdGte(i32),
		LocalIdNot(i32),
		CasIdEquals(Vec<u8>),
		CasIdInVec(Vec<Vec<u8>>),
		CasIdNotInVec(Vec<Vec<u8>>),
		CasIdNot(Vec<u8>),
		FilePathsSome(Vec<super::file_path::WhereParam>),
		FilePathsEvery(Vec<super::file_path::WhereParam>),
		FilePathsNone(Vec<super::file_path::WhereParam>),
		TagOnFileSome(Vec<super::tag_on_file::WhereParam>),
		TagOnFileEvery(Vec<super::tag_on_file::WhereParam>),
		TagOnFileNone(Vec<super::tag_on_file::WhereParam>),
	}
	impl Into<SerializedWhere> for WhereParam {
		fn into(self) -> SerializedWhere {
			match self {
				Self::Not(value) => (
					"NOT".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::Or(value) => (
					"OR".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::LocalIdEquals(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdInVec(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::LocalIdNotInVec(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::LocalIdLt(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdLte(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdGt(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdGte(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdNot(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::CasIdEquals(value) => (
					"cas_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::CasIdInVec(value) => (
					"cas_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::CasIdNotInVec(value) => (
					"cas_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::CasIdNot(value) => (
					"cas_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::FilePathsSome(value) => (
					"file_paths".to_string(),
					SerializedWhereValue::Object(vec![(
						"some".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::FilePathsEvery(value) => (
					"file_paths".to_string(),
					SerializedWhereValue::Object(vec![(
						"every".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::FilePathsNone(value) => (
					"file_paths".to_string(),
					SerializedWhereValue::Object(vec![(
						"none".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::TagOnFileSome(value) => (
					"TagOnFile".to_string(),
					SerializedWhereValue::Object(vec![(
						"some".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::TagOnFileEvery(value) => (
					"TagOnFile".to_string(),
					SerializedWhereValue::Object(vec![(
						"every".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::TagOnFileNone(value) => (
					"TagOnFile".to_string(),
					SerializedWhereValue::Object(vec![(
						"none".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		CasIdEquals(Vec<u8>),
		LocalIdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::CasIdEquals(value) => Self::CasIdEquals(value),
				UniqueWhereParam::LocalIdEquals(value) => Self::LocalIdEquals(value),
			}
		}
	}
	impl From<Operator<Self>> for WhereParam {
		fn from(op: Operator<Self>) -> Self {
			match op {
				Operator::Not(value) => Self::Not(value),
				Operator::And(value) => Self::And(value),
				Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
	pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type FindUnique<'a> =
		prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		Cursor,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> =
		prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
	pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn create(self, cas_id: cas_id::Set, mut _params: Vec<SetParam>) -> Create<'a> {
			_params.push(cas_id.into());
			Create::new(
				self.client._new_query_context(),
				QueryInfo::new("File", _outputs()),
				_params,
			)
		}
		pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				QueryInfo::new("File", _outputs()),
				param.into(),
			)
		}
		pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				QueryInfo::new("File", _outputs()),
				params,
			)
		}
		pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				QueryInfo::new("File", _outputs()),
				params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: (cas_id::Set, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			let (cas_id, mut _params) = _create;
			_params.push(cas_id.into());
			Upsert::new(
				self.client._new_query_context(),
				QueryInfo::new("File", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
	}
}
pub mod tag {
	use super::_prisma::*;
	use super::*;
	pub mod local_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::LocalIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::LocalId(direction)
		}
		pub fn cursor(cursor: i32) -> Cursor {
			Cursor::LocalId(cursor)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::LocalIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::LocalIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::LocalIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::LocalIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::LocalIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::LocalIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::LocalIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementLocalId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementLocalId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyLocalId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideLocalId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetLocalId(value.0)
			}
		}
	}
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn cursor(cursor: Vec<u8>) -> Cursor {
			Cursor::Id(cursor)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::IdInVec(value)
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::IdNotInVec(value)
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::IdNot(value)
		}
		pub struct Set(Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
	}
	pub mod name {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::NameEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::Name(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NameInVec(value)
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NameNotInVec(value)
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::NameLt(value)
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::NameLte(value)
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::NameGt(value)
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::NameGte(value)
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::NameContains(value)
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::NameStartsWith(value)
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::NameEndsWith(value)
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::NameNot(value)
		}
		pub struct Set(String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetName(value.0)
			}
		}
	}
	pub mod tag_on_file {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
			WhereParam::TagOnFileSome(value)
		}
		pub fn every(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
			WhereParam::TagOnFileEvery(value)
		}
		pub fn none(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
			WhereParam::TagOnFileNone(value)
		}
		pub struct Fetch {
			args: tag_on_file::ManyArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<tag_on_file::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
			pub fn order_by(mut self, param: tag_on_file::OrderByParam) -> Self {
				self.args = self.args.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.args = self.args.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.args = self.args.take(value);
				self
			}
			pub fn cursor(mut self, value: impl Into<tag_on_file::Cursor>) -> Self {
				self.args = self.args.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::TagOnFile(fetch.args)
			}
		}
		pub fn fetch(params: Vec<tag_on_file::WhereParam>) -> Fetch {
			Fetch {
				args: tag_on_file::ManyArgs::new(params),
			}
		}
		pub fn link<T: From<Link>>(params: Vec<tag_on_file::UniqueWhereParam>) -> T {
			Link(params).into()
		}
		pub fn unlink(params: Vec<tag_on_file::UniqueWhereParam>) -> SetParam {
			SetParam::UnlinkTagOnFile(params)
		}
		pub struct Link(Vec<tag_on_file::UniqueWhereParam>);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkTagOnFile(value.0)
			}
		}
	}
	pub fn _outputs() -> Vec<Selection> {
		["local_id", "id", "name"]
			.into_iter()
			.map(|o| {
				let builder = Selection::builder(o);
				builder.build()
			})
			.collect()
	}
	#[derive(Debug, Clone, Serialize, Deserialize)]
	pub struct Data {
		#[serde(rename = "local_id")]
		pub local_id: i32,
		#[serde(rename = "id")]
		pub id: Vec<u8>,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "TagOnFile")]
		pub tag_on_file: Option<Vec<super::tag_on_file::Data>>,
	}
	impl Data {
		pub fn tag_on_file(&self) -> Result<&Vec<super::tag_on_file::Data>, &'static str> {
			self.tag_on_file.as_ref().ok_or(
				"Attempted to access 'tag_on_file' but did not fetch it using the .with() syntax",
			)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		TagOnFile(super::tag_on_file::ManyArgs),
	}
	impl Into<Selection> for WithParam {
		fn into(self) -> Selection {
			match self {
				Self::TagOnFile(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(super::tag_on_file::_outputs());
					let mut builder = Selection::builder("TagOnFile");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetLocalId(i32),
		IncrementLocalId(i32),
		DecrementLocalId(i32),
		MultiplyLocalId(i32),
		DivideLocalId(i32),
		SetId(Vec<u8>),
		SetName(String),
		LinkTagOnFile(Vec<super::tag_on_file::UniqueWhereParam>),
		UnlinkTagOnFile(Vec<super::tag_on_file::UniqueWhereParam>),
	}
	impl Into<(String, PrismaValue)> for SetParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				SetParam::SetLocalId(value) => {
					("local_id".to_string(), PrismaValue::Int(value as i64))
				}
				SetParam::IncrementLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideLocalId(value) => (
					"local_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetId(value) => ("id".to_string(), PrismaValue::Bytes(value)),
				SetParam::SetName(value) => ("name".to_string(), PrismaValue::String(value)),
				SetParam::LinkTagOnFile(where_params) => (
					"TagOnFile".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_file::WhereParam>::into),
						)),
					)]),
				),
				SetParam::UnlinkTagOnFile(where_params) => (
					"TagOnFile".to_string(),
					PrismaValue::Object(vec![(
						"disconnect".to_string(),
						PrismaValue::Object(
							transform_equals(
								where_params
									.into_iter()
									.map(Into::<super::tag_on_file::WhereParam>::into),
							)
							.into_iter()
							.collect(),
						),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		LocalId(Direction),
		Id(Direction),
		Name(Direction),
	}
	impl Into<(String, PrismaValue)> for OrderByParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::LocalId(direction) => (
					"local_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::Id(direction) => {
					("id".to_string(), PrismaValue::String(direction.to_string()))
				}
				Self::Name(direction) => (
					"name".to_string(),
					PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum Cursor {
		LocalId(i32),
		Id(Vec<u8>),
	}
	impl Into<(String, PrismaValue)> for Cursor {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::LocalId(cursor) => ("local_id".to_string(), PrismaValue::Int(cursor as i64)),
				Self::Id(cursor) => ("id".to_string(), PrismaValue::Bytes(cursor)),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LocalIdEquals(i32),
		LocalIdInVec(Vec<i32>),
		LocalIdNotInVec(Vec<i32>),
		LocalIdLt(i32),
		LocalIdLte(i32),
		LocalIdGt(i32),
		LocalIdGte(i32),
		LocalIdNot(i32),
		IdEquals(Vec<u8>),
		IdInVec(Vec<Vec<u8>>),
		IdNotInVec(Vec<Vec<u8>>),
		IdNot(Vec<u8>),
		NameEquals(String),
		NameInVec(Vec<String>),
		NameNotInVec(Vec<String>),
		NameLt(String),
		NameLte(String),
		NameGt(String),
		NameGte(String),
		NameContains(String),
		NameStartsWith(String),
		NameEndsWith(String),
		NameNot(String),
		TagOnFileSome(Vec<super::tag_on_file::WhereParam>),
		TagOnFileEvery(Vec<super::tag_on_file::WhereParam>),
		TagOnFileNone(Vec<super::tag_on_file::WhereParam>),
	}
	impl Into<SerializedWhere> for WhereParam {
		fn into(self) -> SerializedWhere {
			match self {
				Self::Not(value) => (
					"NOT".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::Or(value) => (
					"OR".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::LocalIdEquals(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdInVec(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::LocalIdNotInVec(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::LocalIdLt(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdLte(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdGt(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdGte(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::LocalIdNot(value) => (
					"local_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdEquals(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::IdInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::IdNotInVec(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::Bytes(v)).collect(),
						),
					)]),
				),
				Self::IdNot(value) => (
					"id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Bytes(value),
					)]),
				),
				Self::NameEquals(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameInVec(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::NameNotInVec(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value.into_iter().map(|v| PrismaValue::String(v)).collect(),
						),
					)]),
				),
				Self::NameLt(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameLte(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameGt(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameGte(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameContains(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameStartsWith(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameEndsWith(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::NameNot(value) => (
					"name".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::String(value),
					)]),
				),
				Self::TagOnFileSome(value) => (
					"TagOnFile".to_string(),
					SerializedWhereValue::Object(vec![(
						"some".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::TagOnFileEvery(value) => (
					"TagOnFile".to_string(),
					SerializedWhereValue::Object(vec![(
						"every".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::TagOnFileNone(value) => (
					"TagOnFile".to_string(),
					SerializedWhereValue::Object(vec![(
						"none".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(Vec<u8>),
		LocalIdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
				UniqueWhereParam::LocalIdEquals(value) => Self::LocalIdEquals(value),
			}
		}
	}
	impl From<Operator<Self>> for WhereParam {
		fn from(op: Operator<Self>) -> Self {
			match op {
				Operator::Not(value) => Self::Not(value),
				Operator::And(value) => Self::And(value),
				Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
	pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type FindUnique<'a> =
		prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		Cursor,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> =
		prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
	pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn create(self, id: id::Set, mut _params: Vec<SetParam>) -> Create<'a> {
			_params.push(id.into());
			Create::new(
				self.client._new_query_context(),
				QueryInfo::new("Tag", _outputs()),
				_params,
			)
		}
		pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				QueryInfo::new("Tag", _outputs()),
				param.into(),
			)
		}
		pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				QueryInfo::new("Tag", _outputs()),
				params,
			)
		}
		pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				QueryInfo::new("Tag", _outputs()),
				params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: (id::Set, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			let (id, mut _params) = _create;
			_params.push(id.into());
			Upsert::new(
				self.client._new_query_context(),
				QueryInfo::new("Tag", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
	}
}
pub mod tag_on_file {
	use super::_prisma::*;
	use super::*;
	pub mod tag_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::TagIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::TagId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::TagIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::TagIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::TagIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::TagIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::TagIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::TagIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::TagIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementTagId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementTagId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyTagId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideTagId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTagId(value.0)
			}
		}
	}
	pub mod tag {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<tag::WhereParam>) -> WhereParam {
			WhereParam::TagIs(value)
		}
		pub fn is_not(value: Vec<tag::WhereParam>) -> WhereParam {
			WhereParam::TagIsNot(value)
		}
		pub struct Fetch {
			args: tag::UniqueArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<tag::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Tag(fetch.args)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch {
				args: tag::UniqueArgs::new(),
			}
		}
		pub fn link<T: From<Link>>(value: tag::UniqueWhereParam) -> T {
			Link(value).into()
		}
		pub struct Link(tag::UniqueWhereParam);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkTag(value.0)
			}
		}
	}
	pub mod file_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::FileIdEquals(value).into()
		}
		pub fn order(direction: Direction) -> OrderByParam {
			OrderByParam::FileId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::FileIdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::FileIdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::FileIdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::FileIdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::FileIdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::FileIdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::FileIdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementFileId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementFileId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyFileId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideFileId(value)
		}
		pub struct Set(i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetFileId(value.0)
			}
		}
	}
	pub mod file {
		use super::super::*;
		use super::_prisma::*;
		use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<file::WhereParam>) -> WhereParam {
			WhereParam::FileIs(value)
		}
		pub fn is_not(value: Vec<file::WhereParam>) -> WhereParam {
			WhereParam::FileIsNot(value)
		}
		pub struct Fetch {
			args: file::UniqueArgs,
		}
		impl Fetch {
			pub fn with(mut self, params: impl Into<file::WithParam>) -> Self {
				self.args = self.args.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::File(fetch.args)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch {
				args: file::UniqueArgs::new(),
			}
		}
		pub fn link<T: From<Link>>(value: file::UniqueWhereParam) -> T {
			Link(value).into()
		}
		pub struct Link(file::UniqueWhereParam);
		impl From<Link> for SetParam {
			fn from(value: Link) -> Self {
				Self::LinkFile(value.0)
			}
		}
	}
	pub fn tag_id_file_id<T: From<UniqueWhereParam>>(tag_id: i32, file_id: i32) -> T {
		UniqueWhereParam::TagIdFileIdEquals(tag_id, file_id).into()
	}
	pub fn _outputs() -> Vec<Selection> {
		["tag_id", "file_id"]
			.into_iter()
			.map(|o| {
				let builder = Selection::builder(o);
				builder.build()
			})
			.collect()
	}
	#[derive(Debug, Clone, Serialize, Deserialize)]
	pub struct Data {
		#[serde(rename = "tag_id")]
		pub tag_id: i32,
		#[serde(rename = "tag")]
		pub tag: Option<Box<super::tag::Data>>,
		#[serde(rename = "file_id")]
		pub file_id: i32,
		#[serde(rename = "file")]
		pub file: Option<Box<super::file::Data>>,
	}
	impl Data {
		pub fn tag(&self) -> Result<&super::tag::Data, &'static str> {
			self.tag
				.as_ref()
				.ok_or("Attempted to access 'tag' but did not fetch it using the .with() syntax")
				.map(|v| v.as_ref())
		}
		pub fn file(&self) -> Result<&super::file::Data, &'static str> {
			self.file
				.as_ref()
				.ok_or("Attempted to access 'file' but did not fetch it using the .with() syntax")
				.map(|v| v.as_ref())
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Tag(super::tag::UniqueArgs),
		File(super::file::UniqueArgs),
	}
	impl Into<Selection> for WithParam {
		fn into(self) -> Selection {
			match self {
				Self::Tag(args) => {
					let mut selections = super::tag::_outputs();
					selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
					let mut builder = Selection::builder("tag");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::File(args) => {
					let mut selections = super::file::_outputs();
					selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
					let mut builder = Selection::builder("file");
					builder.nested_selections(selections);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetTagId(i32),
		IncrementTagId(i32),
		DecrementTagId(i32),
		MultiplyTagId(i32),
		DivideTagId(i32),
		LinkTag(super::tag::UniqueWhereParam),
		SetFileId(i32),
		IncrementFileId(i32),
		DecrementFileId(i32),
		MultiplyFileId(i32),
		DivideFileId(i32),
		LinkFile(super::file::UniqueWhereParam),
	}
	impl Into<(String, PrismaValue)> for SetParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				SetParam::SetTagId(value) => ("tag_id".to_string(), PrismaValue::Int(value as i64)),
				SetParam::IncrementTagId(value) => (
					"tag_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementTagId(value) => (
					"tag_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyTagId(value) => (
					"tag_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideTagId(value) => (
					"tag_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::LinkTag(where_param) => (
					"tag".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							vec![Into::<super::tag::WhereParam>::into(where_param)].into_iter(),
						)),
					)]),
				),
				SetParam::SetFileId(value) => {
					("file_id".to_string(), PrismaValue::Int(value as i64))
				}
				SetParam::IncrementFileId(value) => (
					"file_id".to_string(),
					PrismaValue::Object(vec![(
						"increment".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementFileId(value) => (
					"file_id".to_string(),
					PrismaValue::Object(vec![(
						"decrement".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyFileId(value) => (
					"file_id".to_string(),
					PrismaValue::Object(vec![(
						"multiply".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideFileId(value) => (
					"file_id".to_string(),
					PrismaValue::Object(vec![(
						"divide".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::LinkFile(where_param) => (
					"file".to_string(),
					PrismaValue::Object(vec![(
						"connect".to_string(),
						PrismaValue::Object(transform_equals(
							vec![Into::<super::file::WhereParam>::into(where_param)].into_iter(),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		TagId(Direction),
		FileId(Direction),
	}
	impl Into<(String, PrismaValue)> for OrderByParam {
		fn into(self) -> (String, PrismaValue) {
			match self {
				Self::TagId(direction) => (
					"tag_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
				Self::FileId(direction) => (
					"file_id".to_string(),
					PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum Cursor {}
	impl Into<(String, PrismaValue)> for Cursor {
		fn into(self) -> (String, PrismaValue) {
			match self {}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		TagIdFileIdEquals(i32, i32),
		TagIdEquals(i32),
		TagIdInVec(Vec<i32>),
		TagIdNotInVec(Vec<i32>),
		TagIdLt(i32),
		TagIdLte(i32),
		TagIdGt(i32),
		TagIdGte(i32),
		TagIdNot(i32),
		TagIs(Vec<super::tag::WhereParam>),
		TagIsNot(Vec<super::tag::WhereParam>),
		FileIdEquals(i32),
		FileIdInVec(Vec<i32>),
		FileIdNotInVec(Vec<i32>),
		FileIdLt(i32),
		FileIdLte(i32),
		FileIdGt(i32),
		FileIdGte(i32),
		FileIdNot(i32),
		FileIs(Vec<super::file::WhereParam>),
		FileIsNot(Vec<super::file::WhereParam>),
	}
	impl Into<SerializedWhere> for WhereParam {
		fn into(self) -> SerializedWhere {
			match self {
				Self::Not(value) => (
					"NOT".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::Or(value) => (
					"OR".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND".to_string(),
					SerializedWhereValue::List(
						value
							.into_iter()
							.map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
							.collect(),
					),
				),
				Self::TagIdFileIdEquals(tag_id, file_id) => (
					"tag_id_file_id".to_string(),
					SerializedWhereValue::Object(vec![
						("tag_id".to_string(), PrismaValue::Int(tag_id as i64)),
						("file_id".to_string(), PrismaValue::Int(file_id as i64)),
					]),
				),
				Self::TagIdEquals(value) => (
					"tag_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::TagIdInVec(value) => (
					"tag_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::TagIdNotInVec(value) => (
					"tag_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::TagIdLt(value) => (
					"tag_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::TagIdLte(value) => (
					"tag_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::TagIdGt(value) => (
					"tag_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::TagIdGte(value) => (
					"tag_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::TagIdNot(value) => (
					"tag_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::TagIs(value) => (
					"tag".to_string(),
					SerializedWhereValue::Object(vec![(
						"is".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::TagIsNot(value) => (
					"tag".to_string(),
					SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::FileIdEquals(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIdInVec(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"in".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::FileIdNotInVec(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						PrismaValue::List(
							value
								.into_iter()
								.map(|v| PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::FileIdLt(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIdLte(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIdGt(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIdGte(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIdNot(value) => (
					"file_id".to_string(),
					SerializedWhereValue::Object(vec![(
						"not".to_string(),
						PrismaValue::Int(value as i64),
					)]),
				),
				Self::FileIs(value) => (
					"file".to_string(),
					SerializedWhereValue::Object(vec![(
						"is".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
				Self::FileIsNot(value) => (
					"file".to_string(),
					SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						PrismaValue::Object(transform_equals(
							value.into_iter().map(Into::<SerializedWhere>::into),
						)),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		TagIdFileIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::TagIdFileIdEquals(tag_id, file_id) => {
					Self::TagIdFileIdEquals(tag_id, file_id)
				}
			}
		}
	}
	impl From<Operator<Self>> for WhereParam {
		fn from(op: Operator<Self>) -> Self {
			match op {
				Operator::Not(value) => Self::Not(value),
				Operator::And(value) => Self::And(value),
				Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
	pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type FindUnique<'a> =
		prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		Cursor,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> =
		prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
	pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn create(
			self,
			tag: tag::Link,
			file: file::Link,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(tag.into());
			_params.push(file.into());
			Create::new(
				self.client._new_query_context(),
				QueryInfo::new("TagOnFile", _outputs()),
				_params,
			)
		}
		pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				QueryInfo::new("TagOnFile", _outputs()),
				param.into(),
			)
		}
		pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				QueryInfo::new("TagOnFile", _outputs()),
				params,
			)
		}
		pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				QueryInfo::new("TagOnFile", _outputs()),
				params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: (tag::Link, file::Link, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			let (tag, file, mut _params) = _create;
			_params.push(tag.into());
			_params.push(file.into());
			Upsert::new(
				self.client._new_query_context(),
				QueryInfo::new("TagOnFile", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
	}
}
pub mod _prisma {
	use super::*;
	use prisma_client_rust::{
		queries::QueryContext,
		query_core::{QueryExecutor, QuerySchema},
		raw, ExecuteRaw, QueryRaw,
	};
	use serde::{Deserialize, Serialize};
	use std::fmt;
	use std::sync::Arc;
	pub struct PrismaClient {
		executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
		query_schema: Arc<QuerySchema>,
	}
	impl fmt::Debug for PrismaClient {
		fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
			f.debug_struct("PrismaClient").finish()
		}
	}
	impl PrismaClient {
		pub(super) fn _new_query_context(&self) -> QueryContext {
			QueryContext::new(&self.executor, self.query_schema.clone())
		}
		pub(super) fn _new(
			executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
			query_schema: Arc<QuerySchema>,
		) -> Self {
			Self {
				executor,
				query_schema,
			}
		}
		pub async fn _query_raw<T: serde::de::DeserializeOwned>(
			&self,
			query: raw::Raw,
		) -> QueryResult<Vec<T>> {
			QueryRaw::new(
				QueryContext::new(&self.executor, self.query_schema.clone()),
				query,
				DATABASE_STR,
			)
			.exec()
			.await
		}
		pub async fn _execute_raw(&self, query: raw::Raw) -> QueryResult<i64> {
			ExecuteRaw::new(
				QueryContext::new(&self.executor, self.query_schema.clone()),
				query,
				DATABASE_STR,
			)
			.exec()
			.await
		}
		pub fn owned_operation(&self) -> owned_operation::Actions {
			owned_operation::Actions { client: &self }
		}
		pub fn shared_operation(&self) -> shared_operation::Actions {
			shared_operation::Actions { client: &self }
		}
		pub fn relation_operation(&self) -> relation_operation::Actions {
			relation_operation::Actions { client: &self }
		}
		pub fn node(&self) -> node::Actions {
			node::Actions { client: &self }
		}
		pub fn location(&self) -> location::Actions {
			location::Actions { client: &self }
		}
		pub fn file_path(&self) -> file_path::Actions {
			file_path::Actions { client: &self }
		}
		pub fn file(&self) -> file::Actions {
			file::Actions { client: &self }
		}
		pub fn tag(&self) -> tag::Actions {
			tag::Actions { client: &self }
		}
		pub fn tag_on_file(&self) -> tag_on_file::Actions {
			tag_on_file::Actions { client: &self }
		}
	}
	#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
	pub enum OwnedOperationScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "timestamp")]
		Timestamp,
		#[serde(rename = "data")]
		Data,
		#[serde(rename = "node_id")]
		NodeId,
	}
	impl ToString for OwnedOperationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Timestamp => "timestamp".to_string(),
				Self::Data => "data".to_string(),
				Self::NodeId => "node_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
	pub enum SharedOperationScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "timestamp")]
		Timestamp,
		#[serde(rename = "record_id")]
		RecordId,
		#[serde(rename = "kind")]
		Kind,
		#[serde(rename = "data")]
		Data,
		#[serde(rename = "node_id")]
		NodeId,
	}
	impl ToString for SharedOperationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Timestamp => "timestamp".to_string(),
				Self::RecordId => "record_id".to_string(),
				Self::Kind => "kind".to_string(),
				Self::Data => "data".to_string(),
				Self::NodeId => "node_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
	pub enum RelationOperationScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "timestamp")]
		Timestamp,
		#[serde(rename = "relation")]
		Relation,
		#[serde(rename = "relation_item")]
		RelationItem,
		#[serde(rename = "relation_group")]
		RelationGroup,
		#[serde(rename = "kind")]
		Kind,
		#[serde(rename = "data")]
		Data,
		#[serde(rename = "node_id")]
		NodeId,
	}
	impl ToString for RelationOperationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Timestamp => "timestamp".to_string(),
				Self::Relation => "relation".to_string(),
				Self::RelationItem => "relation_item".to_string(),
				Self::RelationGroup => "relation_group".to_string(),
				Self::Kind => "kind".to_string(),
				Self::Data => "data".to_string(),
				Self::NodeId => "node_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
	pub enum NodeScalarFieldEnum {
		#[serde(rename = "local_id")]
		LocalId,
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "name")]
		Name,
	}
	impl ToString for NodeScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::LocalId => "local_id".to_string(),
				Self::Id => "id".to_string(),
				Self::Name => "name".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
	pub enum LocationScalarFieldEnum {
		#[serde(rename = "local_id")]
		LocalId,
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "node_id")]
		NodeId,
		#[serde(rename = "name")]
		Name,
	}
	impl ToString for LocationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::LocalId => "local_id".to_string(),
				Self::Id => "id".to_string(),
				Self::NodeId => "node_id".to_string(),
				Self::Name => "name".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
	pub enum FilePathScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "location_id")]
		LocationId,
		#[serde(rename = "parent_id")]
		ParentId,
		#[serde(rename = "file_id")]
		FileId,
		#[serde(rename = "name")]
		Name,
	}
	impl ToString for FilePathScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::LocationId => "location_id".to_string(),
				Self::ParentId => "parent_id".to_string(),
				Self::FileId => "file_id".to_string(),
				Self::Name => "name".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
	pub enum FileScalarFieldEnum {
		#[serde(rename = "local_id")]
		LocalId,
		#[serde(rename = "cas_id")]
		CasId,
	}
	impl ToString for FileScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::LocalId => "local_id".to_string(),
				Self::CasId => "cas_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
	pub enum TagScalarFieldEnum {
		#[serde(rename = "local_id")]
		LocalId,
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "name")]
		Name,
	}
	impl ToString for TagScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::LocalId => "local_id".to_string(),
				Self::Id => "id".to_string(),
				Self::Name => "name".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
	pub enum TagOnFileScalarFieldEnum {
		#[serde(rename = "tag_id")]
		TagId,
		#[serde(rename = "file_id")]
		FileId,
	}
	impl ToString for TagOnFileScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::TagId => "tag_id".to_string(),
				Self::FileId => "file_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
	pub enum SortOrder {
		#[serde(rename = "asc")]
		Asc,
		#[serde(rename = "desc")]
		Desc,
	}
	impl ToString for SortOrder {
		fn to_string(&self) -> String {
			match self {
				Self::Asc => "asc".to_string(),
				Self::Desc => "desc".to_string(),
			}
		}
	}
}
pub use _prisma::PrismaClient;
