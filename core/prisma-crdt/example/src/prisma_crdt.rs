// Code generated by Prisma CRDT Generator. DO NOT EDIT

use crate::prisma;

pub async fn new_client(
	prisma_client: crate::prisma::PrismaClient,
	node_id: Vec<u8>,
	node_local_id: i32,
) -> (
	_prisma::PrismaCRDTClient,
	tokio::sync::mpsc::Receiver<prisma_crdt::CRDTOperation>,
) {
	let (tx, rx) = tokio::sync::mpsc::channel(64);

	let crdt_client = _prisma::PrismaCRDTClient::_new(prisma_client, (node_id, node_local_id), tx);
	(crdt_client, rx)
}
pub mod location {
	use super::*;

	#[derive(Clone, serde::Serialize, serde::Deserialize)]
	pub enum SetParam {
		SetLocalId(i32),
		SetId(Vec<u8>),
		SetNodeId(i32),
		SetName(String),
	}

	impl Into<prisma::location::SetParam> for SetParam {
		fn into(self) -> prisma::location::SetParam {
			match self {
				SetParam::SetId(v) => prisma::location::SetParam::SetId(v),
				SetParam::SetLocalId(v) => prisma::location::SetParam::SetLocalId(v),
				SetParam::SetNodeId(v) => prisma::location::SetParam::SetNodeId(v),
				SetParam::SetName(v) => prisma::location::SetParam::SetName(v),
			}
		}
	}

	#[derive(Clone, serde::Serialize, serde::Deserialize)]
	pub enum CRDTSetParam {
		SetLocalId(i32),
		SetId(Vec<u8>),
		SetNodeId(Vec<u8>),
		SetName(String),
	}

	impl Into<prisma::location::SetParam> for CRDTSetParam {
		fn into(self) -> prisma::location::SetParam {
			match self {
				CRDTSetParam::SetId(v) => prisma::location::id::set(v),
				CRDTSetParam::SetLocalId(v) => prisma::location::local_id::set(v),
				CRDTSetParam::SetNodeId(v) => {
					prisma::location::node::link(prisma::node::id::equals(v))
				}
				CRDTSetParam::SetName(v) => prisma::location::name::set(v),
			}
		}
	}

	pub struct Create<'a> {
		client: &'a _prisma::PrismaCRDTClient,
		set_params: CreateSetParams,
		with_params: Vec<crate::prisma::location::WithParam>,
	}

	#[derive(Clone, serde::Serialize, serde::Deserialize)]
	pub struct CreateSetParams {
		id: Vec<u8>,
		name: String,
		#[serde(default, skip_serializing_if = "Vec::is_empty", rename = "_")]
		_params: Vec<SetParam>,
	}

	#[derive(Clone, serde::Serialize, serde::Deserialize)]
	pub struct CRDTCreateParams {
		pub id: Vec<u8>,
		pub name: String,
		#[serde(default, skip_serializing_if = "Vec::is_empty", rename = "_")]
		pub _params: Vec<CRDTSetParam>,
	}

	impl<'a> Create<'a> {
		pub fn with(mut self, param: impl Into<crate::prisma::location::WithParam>) -> Self {
			self.with_params.push(param.into());
			self
		}

		pub async fn exec(
			self,
		) -> Result<crate::prisma::location::Data, crate::prisma::QueryError> {
			let Self {
				client,
				set_params,
				with_params,
			} = self;

			// THIS SHOULD BE IN A TRANSACTION

			let CreateSetParams {
				id: field_0,
				name: field_2,
				_params,
			} = set_params.clone();

			let res = client
				.client
				.location()
				.create(
					crate::prisma::location::id::set(field_0),
					crate::prisma::location::node::link(crate::prisma::node::local_id::equals(
						self.client.node_local_id,
					)),
					crate::prisma::location::name::set(field_2),
					_params.into_iter().map(Into::into).collect::<Vec<_>>(),
				)
				.exec()
				.await;

			let op = {
				let set_params_map = match serde_json::to_value(set_params).unwrap() {
					serde_json::Value::Object(m) => m,
					_ => unreachable!(),
				};

				use prisma::owned_operation::*;

				let op = prisma_crdt::OwnedOperation {
					model: "Location".to_string(),
					data: vec![prisma_crdt::OwnedOperationData::Create(set_params_map)],
				};

				client
					.client
					.owned_operation()
					.create(
						timestamp::set(vec![]), // TODO: use HLC timestamp
						data::set(serde_json::to_vec(&op).unwrap()),
						node::link(prisma::node::local_id::equals(client.node_local_id)), // TODO: Use actual node local ID,
						vec![],
					)
					.exec()
					.await
					.unwrap();

				op
			};

			let op = prisma_crdt::CRDTOperation {
				node: self.client.node_id.clone(), // TODO: Use actual node local ID
				timestamp: uhlc::NTP64(0),
				typ: prisma_crdt::CRDTOperationType::Owned(op),
			};

			client._send_operation(op).await;

			res
		}
	}

	pub struct Actions<'a> {
		pub(super) client: &'a _prisma::PrismaCRDTClient,
	}

	impl<'a> Actions<'a> {
		pub fn create(&self, id: Vec<u8>, name: String, mut _params: Vec<SetParam>) -> Create {
			Create {
				client: self.client,
				set_params: CreateSetParams { id, name, _params },
				with_params: vec![],
			}
		}

		pub fn find_unique(
			&self,
			param: crate::prisma::location::UniqueWhereParam,
		) -> crate::prisma::location::FindUnique {
			self.client.client.location().find_unique(param)
		}

		pub fn find_many(
			&self,
			params: Vec<crate::prisma::location::WhereParam>,
		) -> crate::prisma::location::FindMany {
			self.client.client.location().find_many(params)
		}
	}
}
pub mod file_path {
	use super::*;

	#[derive(Clone, serde::Serialize, serde::Deserialize)]
	pub enum SetParam {
		SetId(i32),
		SetLocationId(i32),
		SetFileId(Option<i32>),
		SetParentId(Option<i32>),
	}

	impl Into<prisma::file_path::SetParam> for SetParam {
		fn into(self) -> prisma::file_path::SetParam {
			match self {
				SetParam::SetId(id) => prisma::file_path::id::set(id),
				SetParam::SetLocationId(id) => prisma::file_path::SetParam::SetLocationId(id),
				SetParam::SetFileId(id) => prisma::file_path::SetParam::SetFileId(id),
				SetParam::SetParentId(id) => prisma::file_path::SetParam::SetParentId(id),
			}
		}
	}

	#[derive(Clone, serde::Serialize, serde::Deserialize)]
	pub enum CRDTSetParam {
		SetId(i32),
		SetLocationId(Vec<u8>),
		SetFileId(Option<i32>), // An owned record can only have intra-table relations to records with the same owner
		SetParentId(Option<i32>),
	}

	impl Into<prisma::file_path::SetParam> for CRDTSetParam {
		fn into(self) -> prisma::file_path::SetParam {
			match self {
				CRDTSetParam::SetId(id) => prisma::file_path::id::set(id),
				CRDTSetParam::SetLocationId(id) => {
					prisma::file_path::location::link(prisma::location::id::equals(id))
				}
				CRDTSetParam::SetFileId(id) => prisma::file_path::file_id::set(id),
				CRDTSetParam::SetParentId(id) => prisma::file_path::parent_id::set(id),
			}
		}
	}

	pub struct Create<'a> {
		client: &'a _prisma::PrismaCRDTClient,
		set_params: CreateParams,
		with_params: Vec<crate::prisma::file_path::WithParam>,
	}

	#[derive(Clone)]
	pub(super) struct CreateParams {
		id: i32,
		location_id: i32,
		name: String,
		_params: Vec<SetParam>,
	}

	#[derive(Clone, serde::Serialize, serde::Deserialize)]
	pub(super) struct CRDTCreateParams {
		pub id: i32,
		pub location_id: Vec<u8>,
		pub name: String,
		#[serde(default, skip_serializing_if = "Vec::is_empty", rename = "_")]
		pub _params: Vec<CRDTSetParam>,
	}

	impl<'a> Create<'a> {
		pub fn with(mut self, param: impl Into<crate::prisma::file_path::WithParam>) -> Self {
			self.with_params.push(param.into());
			self
		}

		pub async fn exec(
			self,
		) -> Result<crate::prisma::file_path::Data, crate::prisma::QueryError> {
			let Self {
				client, set_params, ..
			} = self;

			// THIS SHOULD BE IN A TRANSACTION

			let CreateParams {
				id: field_0,
				location_id: field_1,
				name: field_2,
				_params,
			} = set_params.clone();

			let res = client
				.client
				.file_path()
				.create(
					crate::prisma::file_path::id::set(field_0),
					crate::prisma::file_path::location::link(
						crate::prisma::location::local_id::equals(field_1),
					),
					crate::prisma::file_path::name::set(field_2),
					_params.into_iter().map(Into::into).collect::<Vec<_>>(),
				)
				.exec()
				.await;

			let op = {
				let CreateParams {
					id: field_0,
					location_id: field_1,
					name: field_2,
					_params,
				} = set_params;

				let set_params_map = match serde_json::to_value(CRDTCreateParams {
					id: field_0,
					location_id: {
						let record = client
							.client
							.location()
							.find_unique(crate::prisma::location::local_id::equals(field_1))
							.exec()
							.await
							.unwrap()
							.unwrap();

						record.id
					},
					name: field_2,
					_params: vec![], //_params.into_iter().map(Into::into).collect(),
				})
				.unwrap()
				{
					serde_json::Value::Object(m) => m,
					_ => unreachable!(),
				};

				use prisma::owned_operation::*;

				let op = prisma_crdt::OwnedOperation {
					model: "FilePath".to_string(),
					data: vec![prisma_crdt::OwnedOperationData::Create(set_params_map)],
				};

				client
					.client
					.owned_operation()
					.create(
						timestamp::set(vec![]), // TODO: use HLC timestamp
						data::set(serde_json::to_vec(&op).unwrap()),
						node::link(prisma::node::local_id::equals(client.node_local_id)), // TODO: Use actual node local ID,
						vec![],
					)
					.exec()
					.await
					.unwrap();

				op
			};

			let op = prisma_crdt::CRDTOperation {
				node: self.client.node_id.clone(), // TODO: Use actual node local ID
				timestamp: uhlc::NTP64(0),
				typ: prisma_crdt::CRDTOperationType::Owned(op),
			};

			client._send_operation(op).await;

			res
		}
	}

	pub struct Actions<'a> {
		pub(super) client: &'a _prisma::PrismaCRDTClient,
	}

	impl<'a> Actions<'a> {
		pub fn create(
			&self,
			id: i32,
			location_id: i32,
			name: String,
			mut _params: Vec<SetParam>,
		) -> Create {
			Create {
				client: self.client,
				set_params: CreateParams {
					id,
					location_id,
					name,
					_params,
				},
				with_params: vec![],
			}
		}
	
		pub fn find_unique(
			&self,
			param: crate::prisma::file_path::UniqueWhereParam,
		) -> crate::prisma::file_path::FindUnique {
			self.client.client.file_path().find_unique(param)
		}

		pub fn find_many(
			&self,
			params: Vec<crate::prisma::file_path::WhereParam>,
		) -> crate::prisma::file_path::FindMany {
			self.client.client.file_path().find_many(params)
		}
	}
}
pub mod tag {
	use super::*;

	#[derive(serde::Serialize, serde::Deserialize)]
	pub enum SetParam {
		SetPubId(Vec<u8>),
		SetName(Option<String>),
		SetTotalFiles(Option<i32>),
		SetRedundancyGoal(Option<i32>),
		SetDateCreated(
			prisma_client_rust::chrono::DateTime<prisma_client_rust::chrono::FixedOffset>,
		),
		SetDateModified(
			prisma_client_rust::chrono::DateTime<prisma_client_rust::chrono::FixedOffset>,
		),
	}

	impl From<(String, prisma_client_rust::PrismaValue)> for prisma::tag::SetParam {
		fn from((name, value): (String, prisma_client_rust::PrismaValue)) -> Self {
			use prisma_client_rust::PrismaValue;

			match (name.as_str(), value) {
				("name", PrismaValue::String(value)) => prisma::tag::SetParam::SetName(value),
				// ("total_files", Value::Number(value)) => prisma::tag::SetParam::
				_ => todo!(),
			}
		}
	}
}
pub mod _prisma {
	use tokio::sync::mpsc::error::SendError;

	use super::*;

	pub struct PrismaCRDTClient {
		pub(super) client: prisma::PrismaClient,
		pub node_id: Vec<u8>,
		pub node_local_id: i32,
		operation_sender: tokio::sync::mpsc::Sender<prisma_crdt::CRDTOperation>,
	}

	impl PrismaCRDTClient {
		pub(super) fn _new(
			client: prisma::PrismaClient,
			(node_id, node_local_id): (Vec<u8>, i32),
			operation_sender: tokio::sync::mpsc::Sender<prisma_crdt::CRDTOperation>,
		) -> Self {
			Self {
				client,
				operation_sender,
				node_id,
				node_local_id,
			}
		}

		pub(super) async fn _send_operation(
			&self,
			op: prisma_crdt::CRDTOperation,
		) -> Result<(), SendError<prisma_crdt::CRDTOperation>> {
			self.operation_sender.send(op).await
		}

		pub async fn _execute_operation(&self, op: prisma_crdt::CRDTOperation) {
			let prisma_crdt::CRDTOperation {
				node,
				timestamp,
				typ,
			} = op;

			match typ {
				prisma_crdt::CRDTOperationType::Shared(op) => {
					let prisma_crdt::SharedOperation {
						record_id,
						model,
						data,
					} = op;

					match model.as_str() {
						"Tag" => match data {
							prisma_crdt::SharedOperationData::Create { data } => {
								self.client
									.tag()
									.create(
										prisma::tag::id::set(vec![]),
										data.into_iter()
											.map(|(k, v)| {
												(
													k,
													serde_json::from_value::<
														prisma_client_rust::PrismaValue,
													>(v)
													.unwrap(),
												)
											})
											.map(Into::into)
											.collect(),
									)
									.exec()
									.await
									.unwrap();
							}
							_ => todo!(),
						},
						_ => {}
					}
				}
				prisma_crdt::CRDTOperationType::Owned(op) => {
					let prisma_crdt::OwnedOperation { model, data } = op;

					match model.as_str() {
						"FilePath" => {
							for data in data {
								match data {
									prisma_crdt::OwnedOperationData::Create(create_args) => {
										let create_args: file_path::CRDTCreateParams =
											serde_json::from_value(serde_json::Value::Object(
												create_args,
											))
											.unwrap();

										let file_path::CRDTCreateParams {
											id: field_0,
											location_id: field_1,
											name: field_2,
											_params,
										} = create_args;

										self.client
											.file_path()
											.create(
												prisma::file_path::id::set(field_0),
												prisma::file_path::location::link(
													prisma::location::id::equals(field_1),
												),
												prisma::file_path::name::set(field_2),
												_params.into_iter().map(Into::into).collect(),
											)
											.exec()
											.await
											.unwrap();
									}
									_ => todo!(),
								}
							}
						}
						"Location" => {
							for data in data {
								match data {
									prisma_crdt::OwnedOperationData::Create(create_args) => {
										let create_args: location::CRDTCreateParams =
											serde_json::from_value(serde_json::Value::Object(
												create_args,
											))
											.unwrap();

										let location::CRDTCreateParams {
											id: field_0,
											name: field_1,
											_params,
										} = create_args;

										self.client
											.location()
											.create(
												prisma::location::id::set(field_0),
												prisma::location::node::link(
													prisma::node::id::equals(node.clone()),
												),
												prisma::location::name::set(field_1),
												_params.into_iter().map(Into::into).collect(),
											)
											.exec()
											.await
											.unwrap();
									}
									_ => todo!(),
								}
							}
						}
						_ => todo!(),
					}
				}
				_ => todo!(),
			}
		}

		pub fn node(&self) -> prisma::node::Actions {
			self.client.node()
		}

		pub fn location(&self) -> location::Actions {
			location::Actions { client: self }
		}

		pub fn file_path(&self) -> file_path::Actions {
			file_path::Actions { client: self }
		}
	}
}
pub use _prisma::*;
