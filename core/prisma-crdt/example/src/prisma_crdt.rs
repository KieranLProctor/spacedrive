// Code generated by Prisma CRDT Generator. DO NOT EDIT

pub async fn new_client(
	prisma_client: crate::prisma::PrismaClient,
	node_id: Vec<u8>,
	node_local_id: i32,
) -> (
	_prisma::PrismaCRDTClient,
	::tokio::sync::mpsc::Receiver<::prisma_crdt::CRDTOperation>,
) {
	let (tx, rx) = ::tokio::sync::mpsc::channel(64);
	let crdt_client = _prisma::PrismaCRDTClient::_new(prisma_client, (node_id, node_local_id), tx);
	(crdt_client, rx)
}
pub use crate::prisma::node;
pub use _prisma::*;
pub mod location {
	pub use crate::prisma::location::*;
	#[derive(Clone)]
	pub enum SetParam {
		SetId(Vec<u8>),
		SetNodeId(i32),
		SetName(String),
	}
	impl SetParam {
		pub async fn into_crdt(self, client: &super::_prisma::PrismaCRDTClient) -> CRDTSetParam {
			match self {
				Self::SetId(v) => CRDTSetParam::SetId(v),
				Self::SetNodeId(v) => CRDTSetParam::SetNodeId(
					client
						.node()
						.find_unique(crate::prisma::node::local_id::equals(v))
						.exec()
						.await
						.unwrap()
						.unwrap()
						.id,
				),
				Self::SetName(v) => CRDTSetParam::SetName(v),
			}
		}
	}
	impl From<crate::prisma::location::id::Set> for SetParam {
		fn from(v: crate::prisma::location::id::Set) -> Self {
			Self::SetId(v.0)
		}
	}
	impl From<crate::prisma::location::node_id::Set> for SetParam {
		fn from(v: crate::prisma::location::node_id::Set) -> Self {
			Self::SetNodeId(v.0)
		}
	}
	impl From<crate::prisma::location::name::Set> for SetParam {
		fn from(v: crate::prisma::location::name::Set) -> Self {
			Self::SetName(v.0)
		}
	}
	impl Into<crate::prisma::location::SetParam> for SetParam {
		fn into(self) -> crate::prisma::location::SetParam {
			match self {
				Self::SetId(v) => crate::prisma::location::id::set(v),
				Self::SetNodeId(v) => crate::prisma::location::node_id::set(v),
				Self::SetName(v) => crate::prisma::location::name::set(v),
			}
		}
	}
	#[derive(Clone, serde :: Serialize, serde :: Deserialize)]
	pub enum CRDTSetParam {
		#[serde(rename = "id")]
		SetId(Vec<u8>),
		#[serde(rename = "node_id")]
		SetNodeId(Vec<u8>),
		#[serde(rename = "name")]
		SetName(String),
	}
	impl Into<crate::prisma::location::SetParam> for CRDTSetParam {
		fn into(self) -> crate::prisma::location::SetParam {
			match self {
				Self::SetId(v) => crate::prisma::location::id::set(v),
				Self::SetNodeId(v) => {
					crate::prisma::location::node::link(crate::prisma::node::id::equals(v))
				}
				Self::SetName(v) => crate::prisma::location::name::set(v),
			}
		}
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct SyncID {
		pub id: Vec<u8>,
	}
	#[derive(Clone)]
	pub struct CreateParams {
		pub _params: Vec<SetParam>,
		pub id: Vec<u8>,
		pub node_id: i32,
		pub name: String,
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct CRDTCreateParams {
		#[serde(default, skip_serializing_if = "Vec::is_empty", rename = "_")]
		pub _params: Vec<CRDTSetParam>,
		#[serde(flatten)]
		pub _sync_id: SyncID,
		pub node_id: Vec<u8>,
		pub name: String,
	}
	pub struct Create<'a> {
		crdt_client: &'a super::_prisma::PrismaCRDTClient,
		set_params: CreateParams,
		with_params: Vec<crate::prisma::location::WithParam>,
	}
	impl<'a> Create<'a> {
		pub(super) fn new(
			crdt_client: &'a super::_prisma::PrismaCRDTClient,
			set_params: CreateParams,
			with_params: Vec<crate::prisma::location::WithParam>,
		) -> Self {
			Self {
				crdt_client,
				set_params,
				with_params,
			}
		}
		pub fn with(mut self, param: impl Into<crate::prisma::location::WithParam>) -> Self {
			self.with_params.push(param.into());
			self
		}
		pub async fn exec(
			self,
		) -> Result<crate::prisma::location::Data, crate::prisma::QueryError> {
			let res = self
				.crdt_client
				.client
				.location()
				.create(
					self.set_params.id.clone(),
					crate::prisma::node::local_id::equals(self.set_params.node_id.clone()),
					self.set_params.name.clone(),
					self.set_params
						._params
						.clone()
						.into_iter()
						.map(Into::into)
						.collect(),
				)
				.exec()
				.await?;
			let sync_id = super::location::SyncID {
				id: self.set_params.id,
			};
			let params = CRDTCreateParams {
				_params: {
					let mut params = vec![];
					for _param in self.set_params._params {
						params.push(_param.into_crdt(&self.crdt_client).await);
					}
					params
				},
				_sync_id: sync_id.clone(),
				node_id: self
					.crdt_client
					.client
					.node()
					.find_unique(crate::prisma::node::local_id::equals(
						self.set_params.node_id,
					))
					.exec()
					.await
					.unwrap()
					.unwrap()
					.id,
				name: self.set_params.name,
			};
			let params_map = ::prisma_crdt::objectify(params);
			self.crdt_client
				._create_operation(::prisma_crdt::CRDTOperationType::owned(
					"Location",
					vec![::prisma_crdt::OwnedOperationData::Create(params_map)],
				))
				.await;
			Ok(res)
		}
	}
	pub struct Actions<'a> {
		client: &'a super::_prisma::PrismaCRDTClient,
	}
	impl<'a> Actions<'a> {
		pub(super) fn new(client: &'a super::_prisma::PrismaCRDTClient) -> Self {
			Self { client }
		}
		pub fn create(
			self,
			id: Vec<u8>,
			node_id: i32,
			name: String,
			_params: Vec<SetParam>,
		) -> Create<'a> {
			Create::new(
				self.client,
				CreateParams {
					id,
					node_id,
					name,
					_params,
				},
				vec![],
			)
		}
		pub fn find_unique(
			self,
			param: crate::prisma::location::UniqueWhereParam,
		) -> crate::prisma::location::FindUnique<'a> {
			self.client.client.location().find_unique(param)
		}
		pub fn find_many(
			self,
			params: Vec<crate::prisma::location::WhereParam>,
		) -> crate::prisma::location::FindMany<'a> {
			self.client.client.location().find_many(params)
		}
	}
}
pub mod file_path {
	pub use crate::prisma::file_path::*;
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		SetLocationId(i32),
		SetParentId(Option<i32>),
		SetFileId(Option<i32>),
		SetName(String),
	}
	impl SetParam {
		pub async fn into_crdt(self, client: &super::_prisma::PrismaCRDTClient) -> CRDTSetParam {
			match self {
				Self::SetId(v) => CRDTSetParam::SetId(v),
				Self::SetLocationId(v) => CRDTSetParam::SetLocationId(
					client
						.location()
						.find_unique(crate::prisma::location::local_id::equals(v))
						.exec()
						.await
						.unwrap()
						.unwrap()
						.id,
				),
				Self::SetParentId(v) => CRDTSetParam::SetParentId(v),
				Self::SetFileId(v) => CRDTSetParam::SetFileId(match v {
					Some(v) => Some(
						client
							.file()
							.find_unique(crate::prisma::file::local_id::equals(v))
							.exec()
							.await
							.unwrap()
							.unwrap()
							.cas_id,
					),
					None => None,
				}),
				Self::SetName(v) => CRDTSetParam::SetName(v),
			}
		}
	}
	impl From<crate::prisma::file_path::id::Set> for SetParam {
		fn from(v: crate::prisma::file_path::id::Set) -> Self {
			Self::SetId(v.0)
		}
	}
	impl From<crate::prisma::file_path::location_id::Set> for SetParam {
		fn from(v: crate::prisma::file_path::location_id::Set) -> Self {
			Self::SetLocationId(v.0)
		}
	}
	impl From<crate::prisma::file_path::parent_id::Set> for SetParam {
		fn from(v: crate::prisma::file_path::parent_id::Set) -> Self {
			Self::SetParentId(v.0)
		}
	}
	impl From<crate::prisma::file_path::file_id::Set> for SetParam {
		fn from(v: crate::prisma::file_path::file_id::Set) -> Self {
			Self::SetFileId(v.0)
		}
	}
	impl From<crate::prisma::file_path::name::Set> for SetParam {
		fn from(v: crate::prisma::file_path::name::Set) -> Self {
			Self::SetName(v.0)
		}
	}
	impl Into<crate::prisma::file_path::SetParam> for SetParam {
		fn into(self) -> crate::prisma::file_path::SetParam {
			match self {
				Self::SetId(v) => crate::prisma::file_path::id::set(v),
				Self::SetLocationId(v) => crate::prisma::file_path::location_id::set(v),
				Self::SetParentId(v) => crate::prisma::file_path::parent_id::set(v),
				Self::SetFileId(v) => crate::prisma::file_path::file_id::set(v),
				Self::SetName(v) => crate::prisma::file_path::name::set(v),
			}
		}
	}
	#[derive(Clone, serde :: Serialize, serde :: Deserialize)]
	pub enum CRDTSetParam {
		#[serde(rename = "id")]
		SetId(i32),
		#[serde(rename = "location_id")]
		SetLocationId(Vec<u8>),
		#[serde(rename = "parent_id")]
		SetParentId(Option<i32>),
		#[serde(rename = "file_id")]
		SetFileId(Option<Vec<u8>>),
		#[serde(rename = "name")]
		SetName(String),
	}
	impl Into<crate::prisma::file_path::SetParam> for CRDTSetParam {
		fn into(self) -> crate::prisma::file_path::SetParam {
			match self {
				Self::SetId(v) => crate::prisma::file_path::id::set(v),
				Self::SetLocationId(v) => {
					crate::prisma::file_path::location::link(crate::prisma::location::id::equals(v))
				}
				Self::SetParentId(v) => crate::prisma::file_path::parent_id::set(v),
				Self::SetFileId(v) => v
					.map(|v| {
						crate::prisma::file_path::file::link(crate::prisma::file::cas_id::equals(v))
					})
					.unwrap_or(crate::prisma::file_path::file::unlink()),
				Self::SetName(v) => crate::prisma::file_path::name::set(v),
			}
		}
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct SyncID {
		pub id: i32,
		pub location_id: Vec<u8>,
	}
	#[derive(Clone)]
	pub struct CreateParams {
		pub _params: Vec<SetParam>,
		pub id: i32,
		pub location_id: i32,
		pub name: String,
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct CRDTCreateParams {
		#[serde(default, skip_serializing_if = "Vec::is_empty", rename = "_")]
		pub _params: Vec<CRDTSetParam>,
		#[serde(flatten)]
		pub _sync_id: SyncID,
		pub name: String,
	}
	pub struct Create<'a> {
		crdt_client: &'a super::_prisma::PrismaCRDTClient,
		set_params: CreateParams,
		with_params: Vec<crate::prisma::file_path::WithParam>,
	}
	impl<'a> Create<'a> {
		pub(super) fn new(
			crdt_client: &'a super::_prisma::PrismaCRDTClient,
			set_params: CreateParams,
			with_params: Vec<crate::prisma::file_path::WithParam>,
		) -> Self {
			Self {
				crdt_client,
				set_params,
				with_params,
			}
		}
		pub fn with(mut self, param: impl Into<crate::prisma::file_path::WithParam>) -> Self {
			self.with_params.push(param.into());
			self
		}
		pub async fn exec(
			self,
		) -> Result<crate::prisma::file_path::Data, crate::prisma::QueryError> {
			let res = self
				.crdt_client
				.client
				.file_path()
				.create(
					self.set_params.id.clone(),
					crate::prisma::location::local_id::equals(self.set_params.location_id.clone()),
					self.set_params.name.clone(),
					self.set_params
						._params
						.clone()
						.into_iter()
						.map(Into::into)
						.collect(),
				)
				.exec()
				.await?;
			let sync_id = super::file_path::SyncID {
				id: self.set_params.id,
				location_id: self
					.crdt_client
					.client
					.location()
					.find_unique(crate::prisma::location::local_id::equals(
						self.set_params.location_id,
					))
					.exec()
					.await
					.unwrap()
					.unwrap()
					.id,
			};
			let params = CRDTCreateParams {
				_params: {
					let mut params = vec![];
					for _param in self.set_params._params {
						params.push(_param.into_crdt(&self.crdt_client).await);
					}
					params
				},
				_sync_id: sync_id.clone(),
				name: self.set_params.name,
			};
			let params_map = ::prisma_crdt::objectify(params);
			self.crdt_client
				._create_operation(::prisma_crdt::CRDTOperationType::owned(
					"FilePath",
					vec![::prisma_crdt::OwnedOperationData::Create(params_map)],
				))
				.await;
			Ok(res)
		}
	}
	pub struct Actions<'a> {
		client: &'a super::_prisma::PrismaCRDTClient,
	}
	impl<'a> Actions<'a> {
		pub(super) fn new(client: &'a super::_prisma::PrismaCRDTClient) -> Self {
			Self { client }
		}
		pub fn create(
			self,
			id: i32,
			location_id: i32,
			name: String,
			_params: Vec<SetParam>,
		) -> Create<'a> {
			Create::new(
				self.client,
				CreateParams {
					id,
					location_id,
					name,
					_params,
				},
				vec![],
			)
		}
		pub fn find_unique(
			self,
			param: crate::prisma::file_path::UniqueWhereParam,
		) -> crate::prisma::file_path::FindUnique<'a> {
			self.client.client.file_path().find_unique(param)
		}
		pub fn find_many(
			self,
			params: Vec<crate::prisma::file_path::WhereParam>,
		) -> crate::prisma::file_path::FindMany<'a> {
			self.client.client.file_path().find_many(params)
		}
	}
}
pub mod file {
	pub use crate::prisma::file::*;
	#[derive(Clone)]
	pub enum SetParam {
		SetCasId(Vec<u8>),
		SetSizeInBytes(i32),
	}
	impl SetParam {
		pub async fn into_crdt(self, client: &super::_prisma::PrismaCRDTClient) -> CRDTSetParam {
			match self {
				Self::SetCasId(v) => CRDTSetParam::SetCasId(v),
				Self::SetSizeInBytes(v) => CRDTSetParam::SetSizeInBytes(v),
			}
		}
	}
	impl From<crate::prisma::file::cas_id::Set> for SetParam {
		fn from(v: crate::prisma::file::cas_id::Set) -> Self {
			Self::SetCasId(v.0)
		}
	}
	impl From<crate::prisma::file::size_in_bytes::Set> for SetParam {
		fn from(v: crate::prisma::file::size_in_bytes::Set) -> Self {
			Self::SetSizeInBytes(v.0)
		}
	}
	impl Into<crate::prisma::file::SetParam> for SetParam {
		fn into(self) -> crate::prisma::file::SetParam {
			match self {
				Self::SetCasId(v) => crate::prisma::file::cas_id::set(v),
				Self::SetSizeInBytes(v) => crate::prisma::file::size_in_bytes::set(v),
			}
		}
	}
	#[derive(Clone, serde :: Serialize, serde :: Deserialize)]
	pub enum CRDTSetParam {
		#[serde(rename = "cas_id")]
		SetCasId(Vec<u8>),
		#[serde(rename = "size_in_bytes")]
		SetSizeInBytes(i32),
	}
	impl Into<crate::prisma::file::SetParam> for CRDTSetParam {
		fn into(self) -> crate::prisma::file::SetParam {
			match self {
				Self::SetCasId(v) => crate::prisma::file::cas_id::set(v),
				Self::SetSizeInBytes(v) => crate::prisma::file::size_in_bytes::set(v),
			}
		}
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct SyncID {
		pub cas_id: Vec<u8>,
	}
	#[derive(Clone)]
	pub struct CreateParams {
		pub _params: Vec<SetParam>,
		pub cas_id: Vec<u8>,
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct CRDTCreateParams {
		#[serde(default, skip_serializing_if = "Vec::is_empty", rename = "_")]
		pub _params: Vec<CRDTSetParam>,
		#[serde(flatten)]
		pub _sync_id: SyncID,
	}
	pub struct Create<'a> {
		crdt_client: &'a super::_prisma::PrismaCRDTClient,
		set_params: CreateParams,
		with_params: Vec<crate::prisma::file::WithParam>,
	}
	impl<'a> Create<'a> {
		pub(super) fn new(
			crdt_client: &'a super::_prisma::PrismaCRDTClient,
			set_params: CreateParams,
			with_params: Vec<crate::prisma::file::WithParam>,
		) -> Self {
			Self {
				crdt_client,
				set_params,
				with_params,
			}
		}
		pub fn with(mut self, param: impl Into<crate::prisma::file::WithParam>) -> Self {
			self.with_params.push(param.into());
			self
		}
		pub async fn exec(self) -> Result<crate::prisma::file::Data, crate::prisma::QueryError> {
			let res = self
				.crdt_client
				.client
				.file()
				.create(
					self.set_params.cas_id.clone(),
					self.set_params
						._params
						.clone()
						.into_iter()
						.map(Into::into)
						.collect(),
				)
				.exec()
				.await?;
			let sync_id = super::file::SyncID {
				cas_id: self.set_params.cas_id,
			};
			self.crdt_client
				._create_operation(::prisma_crdt::CRDTOperationType::shared(
					"File",
					::serde_json::to_value(&sync_id).unwrap(),
					::prisma_crdt::SharedOperationData::create_atomic(),
				))
				.await;
			for param in self.set_params._params {
				let crdt_param = param.into_crdt(self.crdt_client).await;
				let param_map = ::prisma_crdt::objectify(crdt_param);
				for (key, value) in param_map {
					self.crdt_client
						._create_operation(::prisma_crdt::CRDTOperationType::shared(
							"File",
							::serde_json::to_value(&sync_id).unwrap(),
							::prisma_crdt::SharedOperationData::update(key, value),
						))
						.await;
				}
			}
			Ok(res)
		}
	}
	pub struct Actions<'a> {
		client: &'a super::_prisma::PrismaCRDTClient,
	}
	impl<'a> Actions<'a> {
		pub(super) fn new(client: &'a super::_prisma::PrismaCRDTClient) -> Self {
			Self { client }
		}
		pub fn create(self, cas_id: Vec<u8>, _params: Vec<SetParam>) -> Create<'a> {
			Create::new(self.client, CreateParams { cas_id, _params }, vec![])
		}
		pub fn find_unique(
			self,
			param: crate::prisma::file::UniqueWhereParam,
		) -> crate::prisma::file::FindUnique<'a> {
			self.client.client.file().find_unique(param)
		}
		pub fn find_many(
			self,
			params: Vec<crate::prisma::file::WhereParam>,
		) -> crate::prisma::file::FindMany<'a> {
			self.client.client.file().find_many(params)
		}
	}
}
pub mod tag {
	pub use crate::prisma::tag::*;
	#[derive(Clone)]
	pub enum SetParam {
		SetId(Vec<u8>),
		SetName(String),
	}
	impl SetParam {
		pub async fn into_crdt(self, client: &super::_prisma::PrismaCRDTClient) -> CRDTSetParam {
			match self {
				Self::SetId(v) => CRDTSetParam::SetId(v),
				Self::SetName(v) => CRDTSetParam::SetName(v),
			}
		}
	}
	impl From<crate::prisma::tag::id::Set> for SetParam {
		fn from(v: crate::prisma::tag::id::Set) -> Self {
			Self::SetId(v.0)
		}
	}
	impl From<crate::prisma::tag::name::Set> for SetParam {
		fn from(v: crate::prisma::tag::name::Set) -> Self {
			Self::SetName(v.0)
		}
	}
	impl Into<crate::prisma::tag::SetParam> for SetParam {
		fn into(self) -> crate::prisma::tag::SetParam {
			match self {
				Self::SetId(v) => crate::prisma::tag::id::set(v),
				Self::SetName(v) => crate::prisma::tag::name::set(v),
			}
		}
	}
	#[derive(Clone, serde :: Serialize, serde :: Deserialize)]
	pub enum CRDTSetParam {
		#[serde(rename = "id")]
		SetId(Vec<u8>),
		#[serde(rename = "name")]
		SetName(String),
	}
	impl Into<crate::prisma::tag::SetParam> for CRDTSetParam {
		fn into(self) -> crate::prisma::tag::SetParam {
			match self {
				Self::SetId(v) => crate::prisma::tag::id::set(v),
				Self::SetName(v) => crate::prisma::tag::name::set(v),
			}
		}
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct SyncID {
		pub id: Vec<u8>,
	}
	#[derive(Clone)]
	pub struct CreateParams {
		pub _params: Vec<SetParam>,
		pub id: Vec<u8>,
		pub name: String,
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct CRDTCreateParams {
		#[serde(default, skip_serializing_if = "Vec::is_empty", rename = "_")]
		pub _params: Vec<CRDTSetParam>,
		#[serde(flatten)]
		pub _sync_id: SyncID,
		pub name: String,
	}
	pub struct Create<'a> {
		crdt_client: &'a super::_prisma::PrismaCRDTClient,
		set_params: CreateParams,
		with_params: Vec<crate::prisma::tag::WithParam>,
	}
	impl<'a> Create<'a> {
		pub(super) fn new(
			crdt_client: &'a super::_prisma::PrismaCRDTClient,
			set_params: CreateParams,
			with_params: Vec<crate::prisma::tag::WithParam>,
		) -> Self {
			Self {
				crdt_client,
				set_params,
				with_params,
			}
		}
		pub fn with(mut self, param: impl Into<crate::prisma::tag::WithParam>) -> Self {
			self.with_params.push(param.into());
			self
		}
		pub async fn exec(self) -> Result<crate::prisma::tag::Data, crate::prisma::QueryError> {
			let res = self
				.crdt_client
				.client
				.tag()
				.create(
					self.set_params.id.clone(),
					self.set_params.name.clone(),
					self.set_params
						._params
						.clone()
						.into_iter()
						.map(Into::into)
						.collect(),
				)
				.exec()
				.await?;
			let sync_id = super::tag::SyncID {
				id: self.set_params.id,
			};
			let params = CRDTCreateParams {
				_params: {
					let mut params = vec![];
					for _param in self.set_params._params {
						params.push(_param.into_crdt(&self.crdt_client).await);
					}
					params
				},
				_sync_id: sync_id.clone(),
				name: self.set_params.name,
			};
			let params_map = ::prisma_crdt::objectify(params);
			self.crdt_client
				._create_operation(::prisma_crdt::CRDTOperationType::shared(
					"Tag",
					::serde_json::to_value(&sync_id).unwrap(),
					::prisma_crdt::SharedOperationData::create_unique(params_map),
				))
				.await;
			Ok(res)
		}
	}
	pub struct Actions<'a> {
		client: &'a super::_prisma::PrismaCRDTClient,
	}
	impl<'a> Actions<'a> {
		pub(super) fn new(client: &'a super::_prisma::PrismaCRDTClient) -> Self {
			Self { client }
		}
		pub fn create(self, id: Vec<u8>, name: String, _params: Vec<SetParam>) -> Create<'a> {
			Create::new(self.client, CreateParams { id, name, _params }, vec![])
		}
		pub fn find_unique(
			self,
			param: crate::prisma::tag::UniqueWhereParam,
		) -> crate::prisma::tag::FindUnique<'a> {
			self.client.client.tag().find_unique(param)
		}
		pub fn find_many(
			self,
			params: Vec<crate::prisma::tag::WhereParam>,
		) -> crate::prisma::tag::FindMany<'a> {
			self.client.client.tag().find_many(params)
		}
	}
}
pub mod tag_on_file {
	pub use crate::prisma::tag_on_file::*;
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct RelationItem {
		pub file_id: Vec<u8>,
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct RelationGroup {
		pub tag_id: Vec<u8>,
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetTagId(i32),
		SetFileId(i32),
	}
	impl SetParam {
		pub async fn into_crdt(self, client: &super::_prisma::PrismaCRDTClient) -> CRDTSetParam {
			match self {
				Self::SetTagId(v) => CRDTSetParam::SetTagId(
					client
						.tag()
						.find_unique(crate::prisma::tag::local_id::equals(v))
						.exec()
						.await
						.unwrap()
						.unwrap()
						.id,
				),
				Self::SetFileId(v) => CRDTSetParam::SetFileId(
					client
						.file()
						.find_unique(crate::prisma::file::local_id::equals(v))
						.exec()
						.await
						.unwrap()
						.unwrap()
						.cas_id,
				),
			}
		}
	}
	impl From<crate::prisma::tag_on_file::tag_id::Set> for SetParam {
		fn from(v: crate::prisma::tag_on_file::tag_id::Set) -> Self {
			Self::SetTagId(v.0)
		}
	}
	impl From<crate::prisma::tag_on_file::file_id::Set> for SetParam {
		fn from(v: crate::prisma::tag_on_file::file_id::Set) -> Self {
			Self::SetFileId(v.0)
		}
	}
	impl Into<crate::prisma::tag_on_file::SetParam> for SetParam {
		fn into(self) -> crate::prisma::tag_on_file::SetParam {
			match self {
				Self::SetTagId(v) => crate::prisma::tag_on_file::tag_id::set(v),
				Self::SetFileId(v) => crate::prisma::tag_on_file::file_id::set(v),
			}
		}
	}
	#[derive(Clone, serde :: Serialize, serde :: Deserialize)]
	pub enum CRDTSetParam {
		#[serde(rename = "tag_id")]
		SetTagId(Vec<u8>),
		#[serde(rename = "file_id")]
		SetFileId(Vec<u8>),
	}
	impl Into<crate::prisma::tag_on_file::SetParam> for CRDTSetParam {
		fn into(self) -> crate::prisma::tag_on_file::SetParam {
			match self {
				Self::SetTagId(v) => {
					crate::prisma::tag_on_file::tag::link(crate::prisma::tag::id::equals(v))
				}
				Self::SetFileId(v) => {
					crate::prisma::tag_on_file::file::link(crate::prisma::file::cas_id::equals(v))
				}
			}
		}
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct SyncID {
		pub tag_id: Vec<u8>,
		pub file_id: Vec<u8>,
	}
	#[derive(Clone)]
	pub struct CreateParams {
		pub _params: Vec<SetParam>,
		pub tag_id: i32,
		pub file_id: i32,
	}
	#[derive(Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct CRDTCreateParams {
		#[serde(default, skip_serializing_if = "Vec::is_empty", rename = "_")]
		pub _params: Vec<CRDTSetParam>,
		#[serde(flatten)]
		pub _sync_id: SyncID,
	}
	pub struct Create<'a> {
		crdt_client: &'a super::_prisma::PrismaCRDTClient,
		set_params: CreateParams,
		with_params: Vec<crate::prisma::tag_on_file::WithParam>,
	}
	impl<'a> Create<'a> {
		pub(super) fn new(
			crdt_client: &'a super::_prisma::PrismaCRDTClient,
			set_params: CreateParams,
			with_params: Vec<crate::prisma::tag_on_file::WithParam>,
		) -> Self {
			Self {
				crdt_client,
				set_params,
				with_params,
			}
		}
		pub fn with(mut self, param: impl Into<crate::prisma::tag_on_file::WithParam>) -> Self {
			self.with_params.push(param.into());
			self
		}
		pub async fn exec(
			self,
		) -> Result<crate::prisma::tag_on_file::Data, crate::prisma::QueryError> {
			let res = self
				.crdt_client
				.client
				.tag_on_file()
				.create(
					crate::prisma::tag::local_id::equals(self.set_params.tag_id.clone()),
					crate::prisma::file::local_id::equals(self.set_params.file_id.clone()),
					self.set_params
						._params
						.clone()
						.into_iter()
						.map(Into::into)
						.collect(),
				)
				.exec()
				.await?;
			let relation_item = RelationItem {
				file_id: self
					.crdt_client
					.client
					.file()
					.find_unique(crate::prisma::file::local_id::equals(
						self.set_params.file_id,
					))
					.exec()
					.await
					.unwrap()
					.unwrap()
					.cas_id,
			};
			let relation_group = RelationGroup {
				tag_id: self
					.crdt_client
					.client
					.tag()
					.find_unique(crate::prisma::tag::local_id::equals(self.set_params.tag_id))
					.exec()
					.await
					.unwrap()
					.unwrap()
					.id,
			};
			self.crdt_client
				._create_operation(::prisma_crdt::CRDTOperationType::relation(
					"TagOnFile",
					::prisma_crdt::objectify(relation_item),
					::prisma_crdt::objectify(relation_group),
					::prisma_crdt::RelationOperationData::create(),
				))
				.await;
			Ok(res)
		}
	}
	pub struct Actions<'a> {
		client: &'a super::_prisma::PrismaCRDTClient,
	}
	impl<'a> Actions<'a> {
		pub(super) fn new(client: &'a super::_prisma::PrismaCRDTClient) -> Self {
			Self { client }
		}
		pub fn create(self, tag_id: i32, file_id: i32, _params: Vec<SetParam>) -> Create<'a> {
			Create::new(
				self.client,
				CreateParams {
					tag_id,
					file_id,
					_params,
				},
				vec![],
			)
		}
		pub fn find_unique(
			self,
			param: crate::prisma::tag_on_file::UniqueWhereParam,
		) -> crate::prisma::tag_on_file::FindUnique<'a> {
			self.client.client.tag_on_file().find_unique(param)
		}
		pub fn find_many(
			self,
			params: Vec<crate::prisma::tag_on_file::WhereParam>,
		) -> crate::prisma::tag_on_file::FindMany<'a> {
			self.client.client.tag_on_file().find_many(params)
		}
	}
}
mod _prisma {
	pub struct PrismaCRDTClient {
		pub(super) client: crate::prisma::PrismaClient,
		pub node_id: Vec<u8>,
		pub node_local_id: i32,
		operation_sender: ::tokio::sync::mpsc::Sender<::prisma_crdt::CRDTOperation>,
	}
	impl PrismaCRDTClient {
		pub(super) fn _new(
			client: crate::prisma::PrismaClient,
			(node_id, node_local_id): (Vec<u8>, i32),
			operation_sender: ::tokio::sync::mpsc::Sender<::prisma_crdt::CRDTOperation>,
		) -> Self {
			Self {
				client,
				operation_sender,
				node_id,
				node_local_id,
			}
		}
		pub async fn _create_operation(&self, typ: ::prisma_crdt::CRDTOperationType) {
			let timestamp = ::uhlc::NTP64(0);
			let timestamp_bytes = vec![0];
			match &typ {
				::prisma_crdt::CRDTOperationType::Shared(::prisma_crdt::SharedOperation {
					record_id,
					model,
					data,
				}) => {
					let (kind, data) = match data {
						::prisma_crdt::SharedOperationData::Create(typ) => {
							("c".to_string(), ::serde_json::to_vec(typ).unwrap())
						}
						::prisma_crdt::SharedOperationData::Update { field, value } => (
							"u".to_string() + field,
							::serde_json::to_vec(value).unwrap(),
						),
						::prisma_crdt::SharedOperationData::Delete => ("d".to_string(), vec![]),
					};
					self.client
						.shared_operation()
						.create(
							timestamp_bytes,
							::serde_json::to_vec(&record_id).unwrap(),
							kind,
							model.to_string(),
							data,
							crate::prisma::node::local_id::equals(self.node_local_id),
							vec![],
						)
						.exec()
						.await;
				}
				::prisma_crdt::CRDTOperationType::Owned(op) => {
					self.client
						.owned_operation()
						.create(
							timestamp_bytes,
							::serde_json::to_vec(op).unwrap(),
							crate::prisma::node::local_id::equals(self.node_local_id),
							vec![],
						)
						.exec()
						.await;
				}
				::prisma_crdt::CRDTOperationType::Relation(::prisma_crdt::RelationOperation {
					relation,
					relation_item,
					relation_group,
					data,
				}) => {
					let (kind, data) = match data {
						::prisma_crdt::RelationOperationData::Create => ("c".to_string(), vec![]),
						::prisma_crdt::RelationOperationData::Update { field, value } => (
							"u".to_string() + field,
							::serde_json::to_vec(value).unwrap(),
						),
						::prisma_crdt::RelationOperationData::Delete => ("d".to_string(), vec![]),
					};
					self.client
						.relation_operation()
						.create(
							timestamp_bytes,
							relation.to_string(),
							::serde_json::to_vec(&relation_item).unwrap(),
							::serde_json::to_vec(&relation_group).unwrap(),
							kind,
							data,
							crate::prisma::node::local_id::equals(self.node_local_id),
							vec![],
						)
						.exec()
						.await;
				}
			}
			let op = ::prisma_crdt::CRDTOperation::new(self.node_id.clone(), timestamp, typ);
			self.operation_sender.send(op).await;
		}
		pub fn node(&self) -> crate::prisma::node::Actions {
			self.client.node()
		}
		pub fn location(&self) -> super::location::Actions {
			super::location::Actions::new(self)
		}
		pub fn file_path(&self) -> super::file_path::Actions {
			super::file_path::Actions::new(self)
		}
		pub fn file(&self) -> super::file::Actions {
			super::file::Actions::new(self)
		}
		pub fn tag(&self) -> super::tag::Actions {
			super::tag::Actions::new(self)
		}
		pub fn tag_on_file(&self) -> super::tag_on_file::Actions {
			super::tag_on_file::Actions::new(self)
		}
	}
}
